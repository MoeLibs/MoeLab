[{"id":"905dda55db61d0a8de91c213d1031275","title":"Markdown基本语法","content":"Markdown 是一种纯文本格式的标记语言，通过简单易学的标记语法，使普通的文本也能有美观的格式。\n一、标题# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n一级标题二级标题三级标题四级标题五级标题六级标题二、字体**加粗的文字**\n*倾斜的文字*\n***斜体加粗的文字***\n~~加删除线的文字~~\n\n加粗的文字倾斜的文字斜体加粗的文字加删除线的文字\n三、引用>引用的内容\n>>引用的内容\n>>>引用的内容\n\n\n\n\n\n\n\n\n\n\n这是引用的内容\n\n这是引用的内容\n\n这是引用的内容\n\n\n四、分割线---\n----\n***\n*****\n\n\n\n\n\n五、图片![Markdown](https://pics.cuonc.com/2021/12/04/2801c14dc3c24677a8aa18e83f9d2024.png \"Markdown\")\n\n\n六、超链接[XiaoJun](https://cuonc.com/)\n\nXiaoJun\n七、列表\n无序列表\n\n- 列表内容\n+ 列表内容\n* 列表内容\n\n\n列表内容\n\n列表内容\n\n列表内容\n\n有序列表\n\n\n1. 列表内容\n2. 列表内容\n3. 列表内容\n\n\n列表内容\n列表内容\n列表内容\n\n\n列表嵌套上一级和下一级之间敲三个空格\n一级无序列表内容\n二级无序列表内容\n二级无序列表内容\n二级无序列表内容\n\n\n一级无序列表内容\n二级有序列表内容 \n二级有序列表内容\n二级有序列表内容\n\n\n\n\n一级有序列表内容\n二级无序列表内容\n二级无序列表内容\n二级无序列表内容\n\n\n一级有序列表内容\n二级有序列表内容\n二级有序列表内容\n二级有序列表内容\n\n\n\n八、表格输出效果|快捷键\n:--:|:--:\n粗体|Ctrl+B\n斜体|Ctrl+I\n超链接|Ctrl+K\n标题|Ctrl+H\n\n\n\n\n输出效果\n快捷键\n\n\n\n粗体\nCtrl+B\n\n\n斜体\nCtrl+I\n\n\n超链接\nCtrl+K\n\n\n标题\nCtrl+H\n\n\n九、代码(```)\n    function fun()&#123;\n         echo \"Hello World!\";\n    &#125;\n    fun();\n(```)\n\nfunction fun()&#123;\n     echo &quot;Hello World!&quot;;\n&#125;\nfun();\n\n","slug":"Markdown基本语法","date":"2021-12-12T09:51:35.000Z","categories_index":"Share","tags_index":"Dev","author_index":"XiaoJun"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2021-12-11T16:12:32.874Z","categories_index":"","tags_index":"","author_index":"XiaoJun"},{"id":"0939f19850519632467a0c98d88676b0","title":"这是一篇水文","content":"\n\n\n\n\n\n\n\n\n标签插件和 Front-matter 中的标签不同，它们是用于在文章中快速插入特定内容的插件。\n虽然你可以使用任何格式书写你的文章，但是标签插件永远可用，且语法也都是一致的。\n","slug":"Test","date":"2021-12-11T09:46:09.000Z","categories_index":"","tags_index":"WDNMD","author_index":"XiaoJun"},{"id":"896e0a094c544537dc77e7a14bb4ade8","title":"Java 学习笔记","content":"JRE 和 JDK\nJRE：Java 程序的运行时环境，包含 JVM 和运行时所需要的核心类库 。\nJDK：Java 程序开发工具包，包含 JRE 和开发人员使用的工具。\n\n编译和运行\n编译：指将编写的 Java 源文件翻译成 JVM 能认识的 class 字节码文件，javac 编译器会检查程序中是否有错，有错误就会提示，无错误则编译成功。\n运行：指将 class 文件 交给 JVM 运行。\n\n基本数据类型\n\n\n数据类型\n关键字\n内存占用\n取值范围\n\n\n\n字节型\nbyte\n1个字节\n-128~127\n\n\n短整型\nshort\n2个字节\n-32768~32767\n\n\n整型\nint（默认）\n4个字节\n-2的31次方~2的31次方-1\n\n\n长整型\nlong\n8个字节\n-2的63次方~2的63次方-1\n\n\n单精度浮点数\nfloat\n4个字节\n-3.4028E+38~3.4028E+38\n\n\n双精度浮点数\ndouble（默认）\n8个字节\n-1.7977E+308~1.7977E+308\n\n\n字符型\nchar\n2个字节\n0~65535\n\n\n布尔型\nboolean\n1个字节\ntrue，false\n\n\n引用数据类型除了八种基本数据类型，其他全都是引用数据类型，如 String。\n数据类型转换\n自动转换：从小到大，byte-short-char–&gt;int–&gt;long–&gt;float–&gt;double\n强制转换：从大到小，浮点到整数可能会发生精度损失，int 转 short 可能会发生数据溢出（丢失）格式：数据类型 变量名 = (数据类型) 被转数据值;\n\nASCII 编码表\n\n\n字符\n数值\n\n\n\n0\n48\n\n\nA\n65\n\n\na\n97\n\n\n在 char 类型和 int 类型计算的过程中，char 类型的字符先查询编码表，得到 97，再和 1 求和，结果为 98。char 类型提升为了 int 类型。char 类型内存 2 个字节，int 类型内存 4 个字节。\n重载和重写\n重载：方法名相同，参数不同，返回类型可以相同也可以不同，方法体不同。一般用在构造器方法上，JVM 会根据传入参数的不同，选择不同的构造方法。\n重写：方法名，参数，返回类型相同，方法体不同。一般用在子类对父类方法的重写，定义子类自己的行为。\n\nJava 内存区域JDK1.8 之后：图片丢失\n类和对象\n类：一类事物的属性和行为的集合，抽象的。\n对象：一类事物的具体体现，类的一个实例，具体的。\n\n类是对象的模板，对象是类的实体。\n成员变量的默认值\n\n\n\n数据类型\n默认值\n\n\n\n基本类型\n整数\n0\n\n\n\n浮点\n0.0\n\n\n\n字符\n‘\\u0000’\n\n\n\n布尔类型\nfalse\n\n\n引用类型\n数组、类、接口\nnull\n\n\n面向对象三大基本特征\n封装：将类的属性和方法隐藏起来，提供一个安全的接口供外界调用，减少耦合。缺点是重复代码，要写很多 getter 和 setter。\n继承：子类继承父类的属性和方法，减少代码重复，提高可维护性，程序更加有层次，缺点是增加了耦合。\n多态：同一个接口或者类，使用不同的实例完成不同的操作。减少耦合，提高可维护性。三个必要条件：继承，重写，父类引用指向子类对象。缺点是无法调用子类特有的方法。\n\nScanner 和 Random//Scanner\nScanner sc = new Scanner(System.in);\nSystem.out.println(\"请输入第一个数据：\");\nint a = sc.nextInt();\n//Random\nRandom r = new Random();\nint i = r.nextInt();\n\n\nJava 集合\nList：顺序结构，有序可以重复\nArrayList：底层是 Object 数组，可以根据 index 快速访问\nLinkedList：底层是双向链表，无法快速访问\n\n\nSet：不允许重复\nHashSet：无序唯一，底层基于 HashMap，存储Key\nLinkedHashSet：底层基于 LinkedHashMap\n\n\nMap：键值对 key&amp;value 形式，key 无法重复，value 可以\nHashMap：底层是数组+链表，链表用于存储哈希冲突产生的多个 value，JDK1.8 之后链表换成了红黑树，查询效率更高\nLinkedHashMap：在 HashMap 基础上增加了一条双向链表，来保证存取顺序一定\n\n\n\nHashSet 检查重复：先计算对象的 hashcode 值，与集合中的其他对象的 hashcode 值比较，如果没有相同的则存储。如果有相同的，则使用 equals() 方法判断是否相同。而 hashcode 并不完美，两个不同的对象，有概率 hashcode 值也相同，所以在需要使用 HashSet 存储对象时，一定要重写 hashcode 和 equals。\n== 与 equals\n没有重写 equals() 方法，则两者相同：对基本类型比较值，对引用类型比较内存地址。\n有重写 equals() 方法，则 equals() 比较的是对象的内容是否相等。\n\nString 类常用方法：equals，length，charAt，indexOf，toCharArray，replace，split\n字符串类，一旦被创建赋值之后，无法改变，只能将变量指向其他字符串的内存地址。\nstatic 关键字可以修饰成员变量和成员方法，被修饰之后的变量和方法属于类，建议直接用类名调用。\n静态代码块：在类加载之后只执行一次。\nArrays 类常用方法：toString，sort，asList\nMath 类常用方法：abs（返回 double 的绝对值），ceil（返回大于等于参数的最小整数），floor（返回小于等于参数最大的整数），round（返回最接近参数的 long，相当于四舍五入）\nfinal 关键字可以修饰类、方法和变量\n\n类：不能被继承\n方法：不能被重写\n变量：基础数据类型不能被重新赋值，引用类型不能再指向另一个对象\n\n权限修饰符\n\n\n\npublic\nprotected\ndefault（空）\nprivate\n\n\n\n同类中\n✔\n✔\n✔\n✔\n\n\n同一包中\n✔\n✔\n✔\n\n\n\n不同包的子类\n✔\n✔\n\n\n\n\n不同包中的无关类\n✔\n\n\n\n\n\npublic 任意访问，private 只有同类能访问，default 只能在同包中访问，protected 在不同包子类中也能访问。\n匿名内部类本质是一个带具体实现父类或父接口的匿名的子类对象。\nnew 父类名或者接口名()&#123;     \n    // 方法重写     \n    @Override      \n    public void method() &#123;         \n        // 执行语句     \n    &#125; \n&#125;;\n\n\nObject 类Java 中所有类的父类\n常用方法：toString，equals\nObjects 是一个工具类，其中的 equals 方法直接传递两个参数，可以防止空指针异常。\nDate 类无参构造自动设置系统当前时间的毫秒时刻（距 1970年1月1日00:00:00 GMT），有参构造传递一个 long 值可以自定义时刻。\n常用方法：getTime（把日期对象转换成时间毫秒值）\nDateFormat 类抽象类，可使用子类 SimpleDateFormat，构造方法传递一个日期格式。\n\n\n\n标识字母（区分大小写）\n含义\n\n\n\ny\n年\n\n\nM\n月\n\n\nd\n日\n\n\nH\n时\n\n\nm\n分\n\n\ns\n秒\n\n\n常用方法：format（将 Date 对象格式化为字符串），parse（将字符串解析为 Date 对象）\nSystem 类常用方法：currentTimeMillis（获取当前时间到 1970年1月1日00:00:00 GMT 的毫秒值），arraycopy（将数组中指定的数据拷贝到另一个数组中）\nStringBuilder 类为了解决 String 类无法修改造成的效率问题。\n无参构造创建一个空的 StringBuilder 容器，有参构造创建一个StringBuilder 容器，传递一个字符串进去。\n常用方法：append（在循环中效率比 + 更高），toString（将 StringBuilder 对象转换成 String 对象）\n包装类基本类型效率高，但是功能少，Java 提供了基本类型对应的包装类，实现更多功能。\n\n\n\n基本类型\n对应的包装类（位于java.lang包中）\n\n\n\nbyte\nByte\n\n\nshort\nShort\n\n\nint\nInteger\n\n\nlong\nLong\n\n\nfloat\nFloat\n\n\ndouble\nDouble\n\n\nchar\nCharacter\n\n\nboolean\nBoolean\n\n\n\n装箱：从基本类型转换成对应的包装类对象\n拆箱：从包装类对象转换成对应的基本类型\n\nJDK1.5 开始，装箱和拆箱可以自动完成。\n基本类型和字符串之间的转换基本类型转换成字符串直接拼接：+””\n字符串转换成对应的基本类型使用对应包装类的 praseXxx 方法\nCollection 集合所有单列集合（List 和 Set）的根接口\n常用方法：add，remove，contains，isEmpty，size\nIterator 接口构造方法获取一个集合对应的迭代器\n常用方法：next（返回下一个元素），hasNext（返回是否还有元素）\n增强 for 的原理是迭代器\nfor(元素的数据类型  变量 : Collection集合or数组)&#123; \n  \t//写操作代码\n&#125;\n\n\n泛型集合里可以存储不同类型的对象，但是没必要，一般都是同类型的。如果传递了不同的类型，取出时会发生强转异常。\n可以在类或方法中预支地使用未知的类型，将运行时异常转移到了编译时期。\n常见的数据类型栈，队列，数组，链表，二叉树\nCollections 工具类常用方法：addAll，shuffle（打乱顺序），sort（排序，按指定规则排序）\ncomparable 和 comparator 的区别\ncomparable 接口下有一个 compareTo(Object obj) 方法用来排序。用于在类中定义排序方法。\ncomparator 接口下有一个 compare(Object obj1, Object obj2) 方法用来排序。用于在匿名内部类中重写排序方法。\n\nThrowable 类\nError：严重错误，无法通过修改代码处理的错误\nException：表示异常，可以通过修改代码纠正使程序继续运行\n\n常用方法：printStackTrace，getMessage\nException 分类编译期异常（如日期格式化异常）和运行时异常（数学异常）\n异常处理：\n\nthrow 直接抛出给调用者\n\nthrows 声明异常给调用者不处理\n\ntry…catch 捕获异常\ntry&#123;      \n    编写可能会出现异常的代码 \n&#125;catch(异常类型  e)&#123;      \n    处理异常的代码      \n        //记录日志/打印异常信息/继续抛出异常 \n&#125;ﬁnally&#123;\n    最终一定执行的代码\n        //当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。\n        //以下情况，ﬁnally 不会被执行：\n        //1.在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行\n\t\t//2.在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行\n\t\t//3.程序所在的线程死亡。\n\t\t//4.关闭 CPU。\n&#125;\n可以捕获多个异常，子异常在父异常上方\n\n\n并发和并行\n并发：多个事件在同一个时间段发生\n并行：多个事件在同一时刻发生\n\n线程和进程\n进程：是指程序的一次执行过程，是系统运行的基本单位。\n线程：是进程中的一个执行单元，一个进程可以产生多个线程。\n\n线程的几种状态new，runnable，blocked，waiting，timewaiting，terminated\n创建线程的方法\n定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。\n创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。\n调用线程对象的start()方法来启动线程。\n\nThread 和 Runnable 的区别实现 Runnable 接口比继承 Thread 类更好：\n\n适合多个相同的程序代码的线程去共享同一个资源。\n可以避免java中的单继承的局限性。\n增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。\n线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。\n\n为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。\nsynchronized 关键字保证被它修饰过的方法或者代码块在同一时刻只有一个线程执行\nsynchronized(同步锁)&#123;      \n    需要同步操作的代码 \n&#125;\n//锁对象可以是任意类型，多个线程对象要使用同一把锁\n\npublic synchronized void method()&#123;     \n    可能会产生线程安全问题的代码   \n&#125;\n//当有执行该方法的线程时，其他线程无法使用此方法\n\n\n说说 sleep() 方法和 wait() 方法区别和共同点?\nsleep 方法不会释放锁，wait 方法会释放锁\n除非使用 wait(long timeout) 方法传递一个时间，否则 wait() 无法自动苏醒，需要其他线程调用 notify\nwait 用于线程间通信，sleep 用于暂停执行\n都可以暂停线程的执行\n\n使用线程池的步骤\n创建线程池\n创建 Runnable 接口子类对象\n提交 Runnable 接口子类对象\n关闭线程池\n\nFile 类\n绝对路径：从盘符开始的路径\n相对路径：相对于项目目录的路径\n\n常用方法：exist，isDirectory，isFile，createNewFile（当且仅当该名称的文件不存在时，创建一个新的空文件），delete，mkdir（创建此File表示的目录），mkdir（创建此File表示的目录以及任何必需但不存在的父目录），list（返回一个String数组，表示该File目录中所有的子文件或目录），listFiles（返回一个File数组，表示该File目录中所有的子文件或目录）\n递归指在当前方法内调用自己的这种现象\n\n直接递归自身调用自身\n间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法\n\n递归一定要有限定条件，保证递归能够停下，并且递归次数不能过多，否则会发生栈内存溢出。构造方法禁止递归。\npublic class DiGuiDemo &#123;    \n    //计算n的阶乘，使用递归完成        \n    public static void main(String[] args) &#123;         \n        int n = 3;        \n        // 调用求阶乘的方法            \n        int value = getValue(n);        \n        // 输出结果\n        System.out.println(\"阶乘为:\"+ value);     &#125; \n    /*           \n    通过递归算法实现.         \n    参数列表:int          \n    返回值类型: int        \n    */        \n    public static int getValue(int n) &#123;        \n        // 1的阶乘为1            \n        if (n == 1) &#123;             \n            return 1;         \n        &#125;        \n        /*             \n        n不为1时,方法返回 n! = n*(n‐1)!              \n        递归调用getValue方法        \n        */            \n        return n * getValue(n ‐ 1);     \n    &#125; \n&#125;\n\n\npublic class DiGuiDemo3 &#123;     \n    public static void main(String[] args) &#123;         \n        // 创建File对象         \n        File dir  = new File(\"D:\\\\aaa\");        \n        // 调用打印目录方法            \n        printDir(dir);     \n    &#125;       \n    public static void printDir(File dir) &#123;        \n        // 获取子文件和目录            \n        File[] files = dir.listFiles();                 \n        // 循环打印            \n        for (File file : files) &#123;             \n            if (file.isFile()) &#123;                \n                // 是文件，判断文件名并输出文件绝对路径\n                if (file.getName().endsWith(\".java\")) &#123;                     \n                    System.out.println(\"文件名:\" + file.getAbsolutePath());                 \n                &#125;             \n            &#125; else &#123;                 \n                // 是目录，继续遍历,形成递归                 \n                printDir(file);             \n            &#125;         \n        &#125;     \n    &#125; \n&#125;\n\n\n文件过滤器public class DiGuiDemo4 &#123;     \n    public static void main(String[] args) &#123;         \n        File dir = new File(\"D:\\\\aaa\");         \n        printDir2(dir);     \n    &#125;        \n    public static void printDir2(File dir) &#123;        \n        // 匿名内部类方式,创建过滤器子类对象  \n        File[] files = dir.listFiles(new FileFilter() &#123;             \n        @Override             \n            public boolean accept(File pathname) &#123;                 \n                return pathname.getName().endsWith(\".java\")||pathname.isDirectory();             \n                                                 \n            &#125;         \n        &#125;);        \n        // 循环打印            \n        for (File file : files) &#123;             \n            if (file.isFile()) &#123;                 \n                System.out.println(\"文件名:\" + file.getAbsolutePath());             \n            &#125; else &#123;                 \n                printDir2(file);             \n            &#125;         \n        &#125;     \n    &#125; \n&#125;\n\n\n字节流字节输出流 OutputStream常用方法：close（完成操作之后必须执行），flush，write\n文件输出流 FileOutputStream构造方法传递 File 对象或者 String 路径创建文件输出流，加一个 true 可追加数据\nWindows 换行符号：\\r\\n\nUnix 换行符号：\\n\n字节输入流 InputStream常用方法：close（完成操作之后必须执行），read（读取字节时会自动提升为int类型）\n文件输入流 FileInputStream构造方法传递 File 对象或者 String 路径创建文件输入流\n字符流中文字符占用多个字节存储，所以使用字符流处理文本文件更方便。使用系统默认的字符编码和默认字节缓冲区。字符流无法处理图片视频等非文本文件。\nFileWriter 与 FileOutputStream 不同， 如果不关闭，数据只是保存到缓冲区，并未保存到文件。\n在 close 执行之后，流对象无法继续使用写出别的内容，所以必须在 close 之前执行 flush 方法。\n在实际开发中，IO 异常一定要处理。\n缓冲流对四个基本流的增强，在创建流对象时，创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统 IO 次数，提高读写效率。\n字节缓冲流：BufferedInputStream，BufferedOutputStream// 创建字节缓冲输入流 \nBufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"bis.txt\")); \n// 创建字节缓冲输出流 \nBufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"bos.txt\"));\n\n\n读取时 read 传递一个 byte 数组，效率更高。\n字符缓冲流：BufferedReader，BufferedWriter// 创建字符缓冲输入流 \nBufferedReader br = new BufferedReader(new FileReader(\"br.txt\")); \n// 创建字符缓冲输出流 \nBufferedWriter bw = new BufferedWriter(new FileWriter(\"bw.txt\"));\n\n\n特有方法：readLine（读取一行文字），newLine（写一行分隔符）\n转换流是字节与字符间的桥梁\nInputStreamReader 类：Reader 的子类，读取字节解码为字符。\nInputStreamReader isr = new InputStreamReader(new FileInputStream(\"in.txt\")); InputStreamReader isr2 = new InputStreamReader(new FileInputStream(\"in.txt\") , \"GBK\");\n\n\nOutputStreamWriter 类：Writer 的子类，读取字符编码为字节。\nOutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(\"out.txt\")); OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(\"out.txt\") , \"GBK\");\n\n\n序列化对象序列化，用一个字节序列表示一个对象，字节序列中存储对象的数据，类型和属性等信息，可以写出到文件，持久化存储。反之，还可以从文件中读取字节序列，重构对象，称为反序列化。\nObjectOutputStream 类\nFileOutputStream fileOut = new FileOutputStream(\"employee.txt\"); ObjectOutputStream out = new ObjectOutputStream(fileOut);\n\n\n一个对象想要序列化，必须实现 Serializable 接口，对象内部的所有属性必须可序列化，如果有某个属性不需要序列化，可使用 transient 关键字修饰。\n常用方法： writeObject（将指定的对象写出）\nObjectInputStream 类：\nFileInputStream fileIn = new FileInputStream(\"employee.txt\"); ObjectInputStream in = new ObjectInputStream(fileIn);\n\n\n常用方法：readObject\n\n如果能找到类对应的 class 文件，则反序列化成功，如果没有，则会抛出 ClassNotFoundException  异常。\n如果找到的 class 文件在序列化对象之后发生了修改，则反序列化失败，抛出  InvalidClassException 异常。\n\nSerializable 提供了序列版本号的功能，验证序列化对象和类的版本是否一致。\nprivate static final long serialVersionUID = 1L; \n//指定1L，即使修改过类，反序列化也不会抛异常报错\n\n\nTCP/IP 协议应用层，传输层，网络层，数据链路层，物理层\nTCP 面向连接，三次握手：\n\n客户端向服务器发出请求，等待服务器确认\n服务器向客户端发回一个相应，通知客户端已经收到了请求\n客户端再次向服务器端发送确认信息，确认连接\n\nUDP 面向无连接，直接传输不需要建立连接\n网络编程三要素：协议，IP 地址，端口号\nSocket 类Socket：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。\n构造方法\nSocket client = new Socket(\"127.0.0.1\", 6666);\n\n\n常用方法：getInputStream（返回此套接字的输入流），getOutputStream，close，shutdownOutput（禁用此套接字的输出流）\nServerSocket 类：这个类实现了服务器套接字，该对象等待通过网络的请求。\nServerSocket server = new ServerSocket(6666);\n\n\n常用方法：accept（侦听并接受连接，返回一个新的 Socket 对象，用于和客户端实现通信）\n注解注解是给计算机看的，注释是给程序员看的。也叫元数据，一种代码级别的说明。\n反射将类的各个组成部分封装为其他对象。\n可以在程序运行过程中操作这些对象，可以解耦，提高程序可扩展性。\n获取 class 对象的方式：\n\nClass.forName(“全类名”)，用于配置文件\n类名.class，用于参数传递\n对象.getClass()，用于对象获取字节码\n\n同一个字节码文件在一次程序运行过程中只会被加载一次。\nclass 对象功能：获取成员变量 Field，获取构造方法 Constructor，获取成员方法 Method，获取全类名\n如何解决无法使用最新的 springboot–2.2.6.RELEASE 下载 dependencies到 maven 的 settings.xml 里注释掉 阿里云的 镜像， 让 maven 从官方库下载，就没问题了\n@RestController 写在类上，导致类中的方法全部返回了 json 数据，无法通过视图解析器跳转到页面@RestController 是包括 @Controller 和 @ResponseBody 的组合注解\n@Repository 和 @Mapper 注解的区别@Mapper 注解是 Mybatis 的注解，是用来说明这个是一个 Mapper，对应的 xxxMapper.xml 就是来实现这个 Mapper。然后在 service 层使用 @Autowired 注解注入。@Repository 注解是 Spring 的注解，使用该注解把当前类注册成一个 bean，再使用 @Autowired注入。接口上的 @Mapper 也是可以去掉的，但是要在启动类上加上 @MapperScan(value = {“cn.yltang.mapper”})。这句话的意思是在指定位置扫描 Mapper 类。\n前置通知切入点方法之前执行\nMVC 设计模式model模型层，封装数据，实体类；view视图层，jsp，html，展示数据；controller控制层，处理程序逻辑\nSpringMVC 中返回 String 时 return 的写法\nreturn “main”，返回视图。\n需要携带request用forward，不需要则redirect。\n相对路径不带/，绝对路径带/。\n\n#{} 与 ${} 的区别#&#123;&#125;表示一个占位符号，通过#&#123;&#125;可以实现 preparedStatement 向占位符中设置值，自动进行 java 类型和 jdbc 类型转换， #&#123;&#125;可以有效防止 sql 注入。 #&#123;&#125;可以接收简单类型值或 pojo 属性值。 如果 parameterType 传输单个简单类型值，#&#123;&#125;括号中可以是 value 或其它名称。\n$&#123;&#125; 表示拼接 sql 串，通过$&#123;&#125;可以将 parameterType 传入的内容拼接在 sql 中且不进行 jdbc 类型转换， $&#123;&#125;可以接收简单类型值或 pojo 属性值，如果 parameterType 传输单个简单类型值，$&#123;&#125;括号中只能是 value。\nMyBatis 设计模式工厂模式 SqlSessionFactory，代理模式 MapperProxyFactory，构建者模式 SqlSessionFactoryBuilder\nMyBatis 自动提交事务的设置@Test \npublic void testSaveUser() throws Exception &#123;   \n    User user = new User();   \n    user.setUsername(\"mybatis user09\"); \n  \t//6.执行操作   \n    int res = userDao.saveUser(user);   \n    System.out.println(res);   \n    System.out.println(user.getId());  \n&#125;   \n@Before//在测试方法执行之前执行  \npublic void init()throws Exception &#123; \n\t//1.读取配置文件   \n    in = Resources.getResourceAsStream(\"SqlMapConfig.xml\");   \n    //2.创建构建者对象   \n    SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();   \n    //3.创建 SqlSession 工厂对象   \n    factory = builder.build(in);\n\t//4.创建 SqlSession 对象   \n    session = factory.openSession(); //传递一个 true 打开自动提交事务\n  \t//5.创建 Dao 的代理对象   \n    userDao = session.getMapper(IUserDao.class);  \n&#125;   \n@After//在测试方法执行完成之后执行  \npublic void destroy() throws Exception&#123;   \n    //7.提交事务 \n    session.commit(); //自动提交事务则此行不需要\n  \t//8.释放资源\n    session.close();\n    in.close();  \n&#125;\n\n\nMybatis 延迟加载就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载\n好处：先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速 度要快。\n坏处：因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗 时间，所以可能造成用户等待时间变长，造成用户体验下降。\n&lt;settings> \n    &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n    &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/> \n&lt;/settings>\n\n\nMybatis 缓存\n一级缓存：是 SqlSession 级别的缓存，只要 SqlSession 没有 flush 或 close，它就存在。\n二级缓存：是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句，多个 SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。 需要开启。\n\n&lt;settings> \n\t&lt;!-- 开启二级缓存的支持 -->  \n    &lt;setting name=\"cacheEnabled\" value=\"true\"/>\n&lt;/settings>\n\n\nMybatis 接口绑定与映射文件名相同，基于动态代理来生成对象执行sql\nMybatis 和 hebernateh是通过实体映射模型全自动，m是写sql半自动\nMybatis 核心对象SqlSessionFactory\nMySQL5.7 之后修改默认密码ALTER USER 'root'@'localhost' IDENTIFIED BY 'root密码';\n\n\n增删改insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);\ndelete from 表名 [where 条件]\nupdate 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];\n\n\n查询select\n\t字段列表\nfrom\n\t表名列表\nwhere\n\t条件列表\ngroup by\n\t分组字段\nhaving\n\t分组之后的条件\norder by\n\t排序\nlimit\n\t分页限定\n\n\n多个字段查询\nselect 字段名1，字段名2... from 表名；\n\n\n去除重复\nselect distinct 字段名1，字段名2... from 表名；\n\n\nwhere 条件\n* > 、&lt; 、&lt;= 、>= 、= 、&lt;>\n* BETWEEN...AND  \n* IN( 集合) \n* LIKE：模糊查询\n\t* 占位符：\n\t\t* _:单个任意字符\n\t\t* %：多个任意字符\n* IS NULL  \n* and  或 &amp;&amp;\n* or  或 || \n* not  或 !\n\t\t\n-- 查询年龄大于等于20 小于等于30\n\t\t\t\nSELECT * FROM student WHERE age >= 20 &amp;&amp;  age &lt;=30;\nSELECT * FROM student WHERE age >= 20 AND  age &lt;=30;\nSELECT * FROM student WHERE age BETWEEN 20 AND 30;\n\t\t\t\n-- 查询年龄22岁，18岁，25岁的信息\nSELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25\nSELECT * FROM student WHERE age IN (22,18,25);\n\t\t\t\n-- 查询英语成绩为null\t\t\t\nSELECT * FROM student WHERE english IS NULL;\n\t\t\t\n-- 查询英语成绩不为null\nSELECT * FROM student WHERE english  IS NOT NULL;\n\t\t\t\n-- 查询姓马的有哪些？ like\nSELECT * FROM student WHERE NAME LIKE '马%';\n\t\t\t\n-- 查询姓名第二个字是化的人\nSELECT * FROM student WHERE NAME LIKE \"_化%\";\n\t\t\t\n-- 查询姓名是3个字的人\nSELECT * FROM student WHERE NAME LIKE '___';\n\n-- 查询姓名中包含德的人\nSELECT * FROM student WHERE NAME LIKE '%德%';\n\n\n排序分组-- 排序 ASC：升序，默认的。DESC：降序。 \norder by 排序字段1 排序方式1 ，  排序字段2 排序方式2...\n\n-- 聚合函数\n1. count：计算个数\n\t1. 一般选择非空的列：主键\n\t2. count(*)\n2. max：计算最大值\n3. min：计算最小值\n4. sum：计算和\n5. avg：计算平均值\n* 注意：聚合函数的计算，排除null值。\n\t\t解决方案：\n\t\t\t1. 选择不包含非空的列进行计算\n\t\t\t2. IFNULL函数\n\n-- 分组查询\n\t1. 语法：group by 分组字段；\n\t2. 注意：\n\t\t1. 分组之后查询的字段：分组字段、聚合函数\n\t\t2. where 和 having 的区别？\n\t\t\t1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来\n\t\t\t2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。\n\n\t\t-- 按照性别分组。分别查询男、女同学的平均分\n\n\t\tSELECT sex , AVG(math) FROM student GROUP BY sex;\n\t\t\n\t\t-- 按照性别分组。分别查询男、女同学的平均分,人数\n\t\t\n\t\tSELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;\n\t\t\n\t\t--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组\n\t\tSELECT sex , AVG(math),COUNT(id) FROM student WHERE math > 70 GROUP BY sex;\n\t\t\n\t\t--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人\n\t\tSELECT sex , AVG(math),COUNT(id) FROM student WHERE math > 70 GROUP BY sex HAVING COUNT(id) > 2;\n\t\t\n\t\tSELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math > 70 GROUP BY sex HAVING 人数 > 2;\n\n-- 分页查询\n\t1. 语法：limit 开始的索引,每页查询的条数;\n\t2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数\n\t\t-- 每页显示3条记录 \n\n\t\tSELECT * FROM student LIMIT 0,3; -- 第1页\n\t\t\n\t\tSELECT * FROM student LIMIT 3,3; -- 第2页\n\t\t\n\t\tSELECT * FROM student LIMIT 6,3; -- 第3页\n\n\t3. limit 是一个MySQL\"方言\"\n\n\n约束* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。\t\n* 分类：\n\t1. 主键约束：primary key 自增 auto_increment\n\t2. 非空约束：not null\n\t3. 唯一约束：unique\n\t4. 外键约束：foreign key\n\n-- 外键约束\nforeign key,让表于表产生关系，从而保证数据的正确性。\n\t1. 在创建表时，可以添加外键\n\t\t* 语法：\n\t\t\tcreate table 表名(\n\t\t\t\t....\n\t\t\t\t外键列\n\t\t\t\tconstraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)\n\t\t\t);\n\n\t2. 删除外键\n\t\tALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\n\n\t3. 创建表之后，添加外键\n\t\tALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);\n\t4. 级联操作\n\t\t1. 添加级联操作\n\t\t\t语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 \n\t\t\t\t\tFOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;\n\t\t2. 分类：\n\t\t\t1. 级联更新：ON UPDATE CASCADE \n\t\t\t2. 级联删除：ON DELETE CASCADE\n\n\n多表查询-- 内连接查询：\n\t\t\t1. 从哪些表中查询数据\n\t\t\t2. 条件是什么\n\t\t\t3. 查询哪些字段\n-- 隐式内连接：使用where条件消除无用数据\n\t\t\t* 例子：\n\t\t\t-- 查询所有员工信息和对应的部门信息\n\n\t\t\tSELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;\n\t\t\t\n\t\t\t-- 查询员工表的名称，性别。部门表的名称\n\t\t\tSELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;\n\t\t\t\n\t\t\tSELECT \n\t\t\t\tt1.name, -- 员工表的姓名\n\t\t\t\tt1.gender,-- 员工表的性别\n\t\t\t\tt2.name -- 部门表的名称\n\t\t\tFROM\n\t\t\t\temp t1,\n\t\t\t\tdept t2\n\t\t\tWHERE \n\t\t\t\tt1.`dept_id` = t2.`id`;\n-- 显式内连接：\n\t\t\t* 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件\n\t\t\t* 例如：\n\t\t\t\t* SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;\t\n\t\t\t\t* SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`;\t\n\n-- 外链接查询：\n\t\t1. 左外连接：\n\t\t\t* 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；\n\t\t\t* 查询的是左表所有数据以及其交集部分。\n\t\t\t* 例子：\n\t\t\t\t-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称\n\t\t\t\tSELECT \tt1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`;\n\t\t2. 右外连接：\n\t\t\t* 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件；\n\t\t\t* 查询的是右表所有数据以及其交集部分。\n\t\t\t* 例子：\n\t\t\t\tSELECT \t* FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`;\n\n-- 子查询：\n\t\t* 概念：查询中嵌套查询，称嵌套查询为子查询。\n\t\t\t-- 查询工资最高的员工信息\n\t\t\t-- 1 查询最高的工资是多少 9000\n\t\t\tSELECT MAX(salary) FROM emp;\n\t\t\t\n\t\t\t-- 2 查询员工信息，并且工资等于9000的\n\t\t\tSELECT * FROM emp WHERE emp.`salary` = 9000;\n\t\t\t\n\t\t\t-- 一条sql就完成这个操作。子查询\n\t\t\tSELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);\n\n\t\t* 子查询不同情况\n\t\t\t1. 子查询的结果是单行单列的：\n\t\t\t\t* 子查询可以作为条件，使用运算符去判断。 运算符： > >= &lt; &lt;= =\n\t\t\t\t* \n\t\t\t\t-- 查询员工工资小于平均工资的人\n\t\t\t\tSELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);\n\t\t\t2. 子查询的结果是多行单列的：\n\t\t\t\t* 子查询可以作为条件，使用运算符in来判断\n\t\t\t\t-- 查询'财务部'和'市场部'所有的员工信息\n\t\t\t\tSELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部';\n\t\t\t\tSELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;\n\t\t\t\t-- 子查询\n\t\t\t\tSELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部');\n\n\t\t\t3. 子查询的结果是多行多列的：\n\t\t\t\t* 子查询可以作为一张虚拟表参与查询\n\t\t\t\t-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息\n\t\t\t\t-- 子查询\n\t\t\t\tSELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` > '2011-11-11') t2\n\t\t\t\tWHERE t1.id = t2.dept_id;\n\t\t\t\t\n\t\t\t\t-- 普通内连接\n\t\t\t\tSELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` >  '2011-11-11'\n\n\n事务如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。\n\n开启事务： start transaction;\n回滚：rollback;\n提交：commit;\n\n事务提交的两种方式：\n自动提交：mysql就是自动提交的，一条DML(增删改)语句会自动提交一次事务\n手动提交：Oracle 数据库默认是手动提交事务，需要先开启事务，再提交\n事务的四大特征：\n\n原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。\n持久性：当事务提交或回滚后，数据库会持久化的保存数据。\n隔离性：多个事务之间。相互独立。\n一致性：事务操作前后，数据总量不变\n\n隔离级别：\n\nread uncommitted：读未提交，产生的问题：脏读、不可重复读、幻读\nread committed：读已提交 （Oracle）产生的问题：不可重复读、幻读\nrepeatable read：可重复读 （MySQL默认）产生的问题：幻读\nserializable：串行化，可以解决所有的问题\n\n批量将数据库中的某个字段的部分字符串更新UPDATE T SET images = REPLACE(images,'#','*')\n\n\n数据表 A 操作三题\n\n\nname\nclass\ngrade\n\n\n\n张三\n英语\n31\n\n\n张三\n语文\n49\n\n\n李四\n数学\n90\n\n\n王五\n英语\n45\n\n\n王五\n语文\n57\n\n\n李四\n化学\n51\n\n\n王五\n化学\n70\n\n\n李四\n语文\n81\n\n\n\n使用 MySQL 语法。用一个 sql 语句 查询出每门课都小于 60 分的学生姓名\n\nSELECT\n\tNAME\nFROM\n\tA\nGROUP BY\n\tNAME\nHAVING\n\tmax(grade) &lt; 60;\n\nSELECT DISTINCT\n\tNAME\nFROM\n\tA\nWHERE\n\tNAME NOT IN (\n\t\tSELECT DISTINCT\n\t\t\tNAME\n\t\tFROM\n\t\t\tA\n\t\tWHERE\n\t\t\tgrade >= 60\n\t);\n\n\n使用 MySQL 语法。用一个 sql 查出出现次数大于 3 次的人名\n\nSELECT DISTINCT\n\tNAME\nFROM\n\tA\nWHERE\n\tNAME IN (\n\t\tSELECT\n\t\t\tNAME\n\t\tFROM\n\t\t\tA\n\t\tGROUP BY\n\t\t\tNAME\n\t\tHAVING\n\t\t\tCOUNT(NAME) >= 3\n\t);\n\n\n使用 MySQL 语法。用一个 sql 查询以下结果，如果分数 0-59 展示不及格 , 60-79 展示良好，80-100 展示优秀\n\n\n\n\nname\nclass\nlevel\n\n\n\n张三\n英语\n不及格\n\n\n张三\n语文\n不及格\n\n\n李四\n数学\n优秀\n\n\n王五\n英语\n不及格\n\n\n王五\n语文\n不及格\n\n\n李四\n化学\n不及格\n\n\n王五\n化学\n良好\n\n\n李四\n语文\n优秀\n\n\nSELECT name,class,\n\t(\n\t\tCASE\n\t\tWHEN grade >= 80 THEN\n\t\t\t'优秀'\n\t\tWHEN grade &lt;= 59 THEN\n\t\t\t'不及格'\n\t\tELSE\n\t\t\t'良好'\n\t\tEND\n\t) as level\nFROM\n\tA;\n\n\n合并两个数据表select * from T1 union all select * from T2;\n\n\n输出数据表中相同的字段select * from T where name in (select name from T group by name having count(*)>1);\n\n\n在已有的表中添加列（字段）ALTER TABLE people ADD name VARCHAR(100);\n\n\n删除数据表 A 中 name 字段为空的数据delete from A where name is null;\n\n\n查询科目语文分数大于 90 分的学生列表SELECT * FROM A where id in(SELECT id from B WHERE score>90 and SUBJECT = \"语文\");\n\n\n查询名字为张三的所有科目的成绩SELECT * FROM B where id in(SELECT id from A WHERE name = \"张三\";\n\n实体类注解\n表名默认使用类名,驼峰转下划线(只对大写字母进行处理),如UserInfo默认对应的表名为user_info。\n表名可以使用@Table(name = &quot;tableName&quot;)进行指定,对不符合第一条默认规则的可以通过这种方式指定表名.\n字段默认和@Column一样,都会作为表字段,表字段默认为Java对象的Field名字驼峰转下划线形式.\n可以使用@Column(name = &quot;fieldName&quot;)指定不符合第3条规则的字段名\n使用@Transient注解可以忽略字段,添加该注解的字段不会作为表字段使用.如果你的实体类中包含了不是数据库表中的字段，你需要给这个字段加上@Transient注解，这样通用Mapper在处理单表操作时就不会将标注的属性当成表字段处理！\n建议一定是有一个@Id注解作为主键的字段,可以有多个@Id注解的字段作为联合主键.\n默认情况下,实体类中如果不存在包含@Id注解的字段,所有的字段都会作为主键字段进行使用(这种效率极低).\n实体类可以继承使用,可以参考测试代码中的tk.mybatis.mapper.model.UserLogin2类.\n由于基本类型,如int作为实体类字段时会有默认值0,而且无法消除,所以实体类中建议不要使用基本类型.\n主键回显：@GeneratedValue(strategy  = GenerationType.IDENTITY)\n\n常用接口方法基础接口Select接口：SelectMapper方法：List select(T record);说明：根据实体中的属性值进行查询，查询条件使用等号\n接口：SelectByPrimaryKeyMapper方法：T selectByPrimaryKey(Object key);说明：根据主键字段进行查询，方法参数必须包含完整的主键属性，查询条件使用等号\n接口：SelectAllMapper方法：List selectAll();说明：查询全部结果，select(null)方法能达到同样的效果\n接口：SelectOneMapper方法：T selectOne(T record);说明：根据实体中的属性进行查询，只能有一个返回值，有多个结果是抛出异常，查询条件使用等号\n接口：SelectCountMapper方法：int selectCount(T record);说明：根据实体中的属性查询总数，查询条件使用等号\nInsert接口：InsertMapper方法：int insert(T record);说明：保存一个实体，null的属性也会保存，不会使用数据库默认值\n接口：InsertSelectiveMapper方法：int insertSelective(T record);说明：保存一个实体，null的属性不会保存，会使用数据库默认值\nUpdate接口：UpdateByPrimaryKeyMapper方法：int updateByPrimaryKey(T record);说明：根据主键更新实体全部字段，null值会被更新\n接口：UpdateByPrimaryKeySelectiveMapper方法：int updateByPrimaryKeySelective(T record);说明：根据主键更新属性不为null的值\nDelete接口：DeleteMapper方法：int delete(T record);说明：根据实体属性作为条件进行删除，查询条件使用等号\n接口：DeleteByPrimaryKeyMapper方法：int deleteByPrimaryKey(Object key);说明：根据主键字段进行删除，方法参数必须包含完整的主键属性\nbase 组合接口接口：BaseSelectMapper方法：包含上面Select的4个方法\n接口：BaseInsertMapper方法：包含上面Insert的2个方法\n接口：BaseUpdateMapper方法：包含上面Update的2个方法\n接口：BaseDeleteMapper方法：包含上面Delete的2个方法\nCRUD 组合接口接口：BaseMapper方法：继承了base组合接口中的4个组合接口，包含完整的CRUD方法\nExample 方法接口：SelectByExampleMapper方法：List selectByExample(Object example);说明：根据Example条件进行查询重点：这个查询支持通过Example类指定查询列，通过selectProperties方法指定查询列\n接口：SelectCountByExampleMapper方法：int selectCountByExample(Object example);说明：根据Example条件进行查询总数\n接口：UpdateByExampleMapper方法：int updateByExample(@Param(&quot;record&quot;) T record, @Param(&quot;example&quot;) Object example);说明：根据Example条件更新实体record包含的全部属性，null值会被更新\n接口：UpdateByExampleSelectiveMapper方法：int updateByExampleSelective(@Param(&quot;record&quot;) T record, @Param(&quot;example&quot;) Object example);说明：根据Example条件更新实体record包含的不是null的属性值\n接口：DeleteByExampleMapper方法：int deleteByExample(Object example);说明：根据Example条件删除数据\nExample 组合接口接口：ExampleMapper方法：包含上面Example中的5个方法\nCondition 方法Condition方法和Example方法作用完全一样，只是为了避免Example带来的歧义，提供的的Condition方法\n接口：SelectByConditionMapper方法：List selectByCondition(Object condition);说明：根据Condition条件进行查询\n接口：SelectCountByConditionMapper方法：int selectCountByCondition(Object condition);说明：根据Condition条件进行查询总数\n接口：UpdateByConditionMapper方法：int updateByCondition(@Param(&quot;record&quot;) T record, @Param(&quot;example&quot;) Object condition);说明：根据Condition条件更新实体record包含的全部属性，null值会被更新\n接口：UpdateByConditionSelectiveMapper方法：int updateByConditionSelective(@Param(&quot;record&quot;) T record, @Param(&quot;example&quot;) Object condition);说明：根据Condition条件更新实体record包含的不是null的属性值\n接口：DeleteByConditionMapper方法：int deleteByCondition(Object condition);说明：根据Condition条件删除数据\nCondition 组合接口接口：ConditionMapper方法：包含上面Condition中的5个方法\nRowBounds默认为内存分页，可以配合PageHelper实现物理分页\n接口：SelectRowBoundsMapper方法：List selectByRowBounds(T record, RowBounds rowBounds);说明：根据实体属性和RowBounds进行分页查询\n接口：SelectByExampleRowBoundsMapper方法：List selectByExampleAndRowBounds(Object example, RowBounds rowBounds);说明：根据example条件和RowBounds进行分页查询\n接口：SelectByConditionRowBoundsMapper方法：List selectByConditionAndRowBounds(Object condition, RowBounds rowBounds);说明：根据example条件和RowBounds进行分页查询，该方法和selectByExampleAndRowBounds完全一样，只是名字改成了Condition\nRowBounds 组合接口接口：RowBoundsMapper方法：包含上面RowBounds中的前两个方法，不包含selectByConditionAndRowBounds\nspecial 特殊接口这些接口针对部分数据库设计，不是所有数据库都支持\n接口：InsertListMapper方法：int insertList(List recordList);说明：批量插入，支持批量插入的数据库可以使用，例如MySQL,H2等，另外该接口限制实体包含id属性并且必须为自增列\n接口：InsertUseGeneratedKeysMapper方法：int insertUseGeneratedKeys(T record);说明：插入数据，限制为实体包含id属性并且必须为自增列，实体配置的主键策略无效\nMySQL 专用接口：MySqlMapper继承方法：int insertList(List recordList);继承方法：int insertUseGeneratedKeys(T record);说明：该接口不包含方法，继承了special中的InsertListMapper和InsertUseGeneratedKeysMapper\nJsp 四个作用域九个内置对象\n\n\n名称\n作用域\n\n\n\napplication\n在所有应用程序中有效\n\n\nsession\n在当前会话中有效\n\n\nrequest\n在当前请求中有效\n\n\npage\n在当前页面有效\n\n\nout，request，response，session，application，pageContext，page，config，exception\n常用快捷键\n\n\n快捷键\n功能\n\n\n\nAlt+Enter\n导入包，自动修正代码\n\n\nCtrl+Y\n删除光标所在行\n\n\nCtrl+D\n复制光标所在行的内容，插入光标位置下面\n\n\nCtrl+Alt+L\n格式化代码\n\n\nCtrl+/\n单行注释\n\n\nCtrl+Shift+/\n选中代码注释，多行注释，再按取消注释\n\n\nAlt+Ins\n自动生成代码，toString，get，set等方法\n\n\nAlt+Shift+上下箭头\n移动当前代码行\n\n\nIDEA 将包展开右键项目目录左边竖向的Project按钮，取消勾选Compact Middle Packages。\nIDEA 设置项目文件夹类型\n在任意需要更改类型的文件夹上右键选择Make Directory as。\n\nFile-Project Structure-Modules。\n\n\nIDEA设置背景图片\n双击shift搜索\n\n输入image\n\n\nCannot access org.springframework.context.ConfigurableApplicationContext新导入项目，提示报 Cannot access org.springframework.context.ConfigurableApplicationContext的错，百度一番，需删除导入项目自动生成的xxx.iml ，然后刷新下右侧maven tab即可，这里记录一下。\n创建版本库在需要创建版本库的目录下执行：\ngit init\n\n\n会创建一个隐藏的.git目录。\nGit 工作流程\n从远程仓库克隆项目至本地：\n\ngit clone https://github.com/luhexyz/site-Blog.git\n\n\n在本地仓库中checkout代码并修改；\n将代码提交到暂存区：\n\ngit add .\n\n\n提交修改到本地仓库：\n\ngit commit -m \"message\"\n\n\n将改动推送到远程仓库：\n\ngit push\n\n\n从远程仓库拉取并合并代码：\n\ngit pull\n\n\nGit 设置代理Windows 下的命令行 CMD 设置代理：\nset https_proxy=http://127.0.0.1:1080\n\n\n在 Git 里设置代理：\ngit config --global https.proxy https://127.0.0.1:1080\n\n\n取消代理：\ngit config --global --unset https.proxy\n\n\nmacOS 下的命令设置代理：\nexport https_proxy=socks5://127.0.0.1:7891\n\n\n添加子模块git submodule add &lt;url> &lt;path>\n\n\n此时子模块文件夹里是空的，在项目根目录执行：\ngit submodule initgit submodule update\n\n\n或者：\ngit submodule update --init --recursive\n\n\n即可下载子模块代码。\n若在整个项目clone时添加--recursive，也可以下载子模块代码：\ngit clone --recursive https://github.com/luhexyz/site-Blog.git\n\n\n删除子模块Kepler为子模块名。\ngit rm --cached Kepler\nrm -rf Kepler\n\n\n删除.gitmodules文件中的相关模块信息：\n[submodule \"Kepler\"]\n  path = Kepler\n  url = https://github.com/AlanDecode/Maverick-Theme-Kepler.git\n\n\n删除.git/config中的相关子模块信息：\n[submodule \"Kepler\"]\n  url = https://github.com/AlanDecode/Maverick-Theme-Kepler.git\n\n\n删除.git文件夹中的相关子模块文件：\nrm -rf .git/modules/Kepler\n","slug":"Java学习笔记","date":"2021-12-12T09:48:21.000Z","categories_index":"Share","tags_index":"Dev,Java","author_index":"XiaoJun"},{"id":"06d127301ffc1444453dc11ac11c2684","title":"Git常用指令","content":"git常用命令一、git常用命令（实用版）\ngit init 初始化仓库\ngit status 查看git状态\ngit add .  \ngit commit -m '注释' \ngit remote add origin 仓库地址\ngit pull origin master 拉取 （注意分支名）\ngit push -u origin master 推送（注意分支名）\ngit checkout 分支名 切换分支\ngit remote update origin --prune 切换远程分支\ngit diff &lt;版本1> &lt;版本2> 比较两个版本的区别\ngit log 可以查看 git 的歷史以及版本號（按 q 退出） git log --oneline 看第一次\n\n二、git常用命令（高级版）\n抛弃本地所有的修改，回到远程仓库的状态:\ngit fetch --all &amp;&amp; git reset --hard origin/master\n\n修改远程仓库的 url\ngit remote set-url origin &lt;URL>\n\n清空缓存\ngit rm -r --cached . \n\n设置自己的名字\ngit config --global user.name \"设置自己的名字\"\n\n设置自己的邮箱\ngit config --global user.email \"设置自己的邮箱\"\n然后一定要再次确认，再次输入\ngit config --global user.email\n\ngit branch -l :查看本地分支\n\ngit branch -r :查看远程分支\n\ngit branch -a :查看全部分支（远程的和本地的）\n三、git代理配置\n设置代理\ngit config --global https.proxy [http://127.0.0.1:1080](http://127.0.0.1:1080/)\n\ngit config --global https.proxy [https://127.0.0.1:1080](https://127.0.0.1:1080/)\n\n取消代理\ngit config --global --unset http.proxy\n\ngit config --global --unset https.proxy    ","slug":"Git常用指令","date":"2021-12-12T09:41:20.000Z","categories_index":"Share","tags_index":"Dev,Git","author_index":"XiaoJun"},{"id":"7f38795fe02036f2cc0c2381e6d23cbe","title":"MySQL学习笔记","content":"MySQL学习笔记\n登录和退出sql服务器# 登录sql\n$ sql -u root -p12345612\n\n# 退出sql数据库服务器\nexit;\n\n基本语法-- 显示所有数据库\nshow databases;\n\n-- 创建数据库\nCREATE DATABASE test;\n\n-- 切换数据库\nuse test;\n\n-- 显示数据库中的所有表\nshow tables;\n\n-- 创建数据表\nCREATE TABLE pet (\n    name VARCHAR(20),\n    owner VARCHAR(20),\n    species VARCHAR(20),\n    sex CHAR(1),\n    birth DATE,\n    death DATE\n);\n\n-- 查看数据表结构\n-- describe pet;\ndesc pet;\n\n-- 查询表\nSELECT * from pet;\n\n-- 插入数据\nINSERT INTO pet VALUES ('puffball', 'Diane', 'hamster', 'f', '1990-03-30', NULL);\n\n-- 修改数据\nUPDATE pet SET name = 'squirrel' where owner = 'Diane';\n\n-- 删除数据\nDELETE FROM pet where name = 'squirrel';\n\n-- 删除表\nDROP TABLE myorder;\n\n建表约束主键约束-- 主键约束\n-- 使某个字段不重复且不得为空，确保表内所有数据的唯一性。\nCREATE TABLE user (\n    id INT PRIMARY KEY,\n    name VARCHAR(20)\n);\n\n-- 联合主键\n-- 联合主键中的每个字段都不能为空，并且加起来不能和已设置的联合主键重复。\nCREATE TABLE user (\n    id INT,\n    name VARCHAR(20),\n    password VARCHAR(20),\n    PRIMARY KEY(id, name)\n);\n\n-- 自增约束\n-- 自增约束的主键由系统自动递增分配。\nCREATE TABLE user (\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    name VARCHAR(20)\n);\n\n-- 添加主键约束\n-- 如果忘记设置主键，还可以通过SQL语句设置（两种方式）：\nALTER TABLE user ADD PRIMARY KEY(id);\nALTER TABLE user MODIFY id INT PRIMARY KEY;\n\n-- 删除主键\nALTER TABLE user drop PRIMARY KEY;\n\n唯一主键-- 建表时创建唯一主键\nCREATE TABLE user (\n    id INT,\n    name VARCHAR(20),\n    UNIQUE(name)\n);\n\n-- 添加唯一主键\n-- 如果建表时没有设置唯一建，还可以通过SQL语句设置（两种方式）：\nALTER TABLE user ADD UNIQUE(name);\nALTER TABLE user MODIFY name VARCHAR(20) UNIQUE;\n\n-- 删除唯一主键\nALTER TABLE user DROP INDEX name;\n\n非空约束-- 建表时添加非空约束\n-- 约束某个字段不能为空\nCREATE TABLE user (\n    id INT,\n    name VARCHAR(20) NOT NULL\n);\n\n-- 移除非空约束\nALTER TABLE user MODIFY name VARCHAR(20);\n\n默认约束-- 建表时添加默认约束\n-- 约束某个字段的默认值\nCREATE TABLE user2 (\n    id INT,\n    name VARCHAR(20),\n    age INT DEFAULT 10\n);\n\n-- 移除非空约束\nALTER TABLE user MODIFY age INT;\n\n外键约束-- 班级\nCREATE TABLE classes (\n    id INT PRIMARY KEY,\n    name VARCHAR(20)\n);\n\n-- 学生表\nCREATE TABLE students (\n    id INT PRIMARY KEY,\n    name VARCHAR(20),\n    -- 这里的 class_id 要和 classes 中的 id 字段相关联\n    class_id INT,\n    -- 表示 class_id 的值必须来自于 classes 中的 id 字段值\n    FOREIGN KEY(class_id) REFERENCES classes(id)\n);\n\n-- 1. 主表（父表）classes 中没有的数据值，在副表（子表）students 中，是不可以使用的；\n-- 2. 主表中的记录被副表引用时，主表不可以被删除。\n\n数据库的三大设计范式1NF只要字段值还可以继续拆分，就不满足第一范式。\n范式设计得越详细，对某些实际操作可能会更好，但并非都有好处，需要对项目的实际情况进行设定。\n2NF在满足第一范式的前提下，其他列都必须完全依赖于主键列。如果出现不完全依赖，只可能发生在联合主键的情况下：\n-- 订单表\nCREATE TABLE myorder (\n    product_id INT,\n    customer_id INT,\n    product_name VARCHAR(20),\n    customer_name VARCHAR(20),\n    PRIMARY KEY (product_id, customer_id)\n);\n\n实际上，在这张订单表中，product_name 只依赖于 product_id ，customer_name 只依赖于 customer_id 。也就是说，product_name 和 customer_id 是没用关系的，customer_name 和 product_id 也是没有关系的。\n这就不满足第二范式：其他列都必须完全依赖于主键列！\nCREATE TABLE myorder (\n    order_id INT PRIMARY KEY,\n    product_id INT,\n    customer_id INT\n);\n\nCREATE TABLE product (\n    id INT PRIMARY KEY,\n    name VARCHAR(20)\n);\n\nCREATE TABLE customer (\n    id INT PRIMARY KEY,\n    name VARCHAR(20)\n);\n\n拆分之后，myorder 表中的 product_id 和 customer_id 完全依赖于 order_id 主键，而 product 和 customer 表中的其他字段又完全依赖于主键。满足了第二范式的设计！\n3NF在满足第二范式的前提下，除了主键列之外，其他列之间不能有传递依赖关系。\nCREATE TABLE myorder (\n    order_id INT PRIMARY KEY,\n    product_id INT,\n    customer_id INT,\n    customer_phone VARCHAR(15)\n);\n\n表中的 customer_phone 有可能依赖于 order_id 、 customer_id 两列，也就不满足了第三范式的设计：其他列之间不能有传递依赖关系。\nCREATE TABLE myorder (\n    order_id INT PRIMARY KEY,\n    product_id INT,\n    customer_id INT\n);\n\nCREATE TABLE customer (\n    id INT PRIMARY KEY,\n    name VARCHAR(20),\n    phone VARCHAR(15)\n);\n\n修改后就不存在其他列之间的传递依赖关系，其他列都只依赖于主键列，满足了第三范式的设计！\n查询练习准备数据-- 创建数据库\nCREATE DATABASE select_test;\n-- 切换数据库\nUSE select_test;\n\n-- 创建学生表\nCREATE TABLE student (\n    no VARCHAR(20) PRIMARY KEY,\n    name VARCHAR(20) NOT NULL,\n    sex VARCHAR(10) NOT NULL,\n    birthday DATE, -- 生日\n    class VARCHAR(20) -- 所在班级\n);\n\n-- 创建教师表\nCREATE TABLE teacher (\n    no VARCHAR(20) PRIMARY KEY,\n    name VARCHAR(20) NOT NULL,\n    sex VARCHAR(10) NOT NULL,\n    birthday DATE,\n    profession VARCHAR(20) NOT NULL, -- 职称\n    department VARCHAR(20) NOT NULL -- 部门\n);\n\n-- 创建课程表\nCREATE TABLE course (\n    no VARCHAR(20) PRIMARY KEY,\n    name VARCHAR(20) NOT NULL,\n    t_no VARCHAR(20) NOT NULL, -- 教师编号\n    -- 表示该 tno 来自于 teacher 表中的 no 字段值\n    FOREIGN KEY(t_no) REFERENCES teacher(no) \n);\n\n-- 成绩表\nCREATE TABLE score (\n    s_no VARCHAR(20) NOT NULL, -- 学生编号\n    c_no VARCHAR(20) NOT NULL, -- 课程号\n    degree DECIMAL,\t-- 成绩\n    -- 表示该 s_no, c_no 分别来自于 student, course 表中的 no 字段值\n    FOREIGN KEY(s_no) REFERENCES student(no),\t\n    FOREIGN KEY(c_no) REFERENCES course(no),\n    -- 设置 s_no, c_no 为联合主键\n    PRIMARY KEY(s_no, c_no)\n);\n\n-- 查看所有表\nSHOW TABLES;\n\n-- 添加学生表数据\nINSERT INTO student VALUES('101', '曾华', '男', '1977-09-01', '95033');\nINSERT INTO student VALUES('102', '匡明', '男', '1975-10-02', '95031');\nINSERT INTO student VALUES('103', '王丽', '女', '1976-01-23', '95033');\nINSERT INTO student VALUES('104', '李军', '男', '1976-02-20', '95033');\nINSERT INTO student VALUES('105', '王芳', '女', '1975-02-10', '95031');\nINSERT INTO student VALUES('106', '陆军', '男', '1974-06-03', '95031');\nINSERT INTO student VALUES('107', '王尼玛', '男', '1976-02-20', '95033');\nINSERT INTO student VALUES('108', '张全蛋', '男', '1975-02-10', '95031');\nINSERT INTO student VALUES('109', '赵铁柱', '男', '1974-06-03', '95031');\n\n-- 添加教师表数据\nINSERT INTO teacher VALUES('804', '李诚', '男', '1958-12-02', '副教授', '计算机系');\nINSERT INTO teacher VALUES('856', '张旭', '男', '1969-03-12', '讲师', '电子工程系');\nINSERT INTO teacher VALUES('825', '王萍', '女', '1972-05-05', '助教', '计算机系');\nINSERT INTO teacher VALUES('831', '刘冰', '女', '1977-08-14', '助教', '电子工程系');\n\n-- 添加课程表数据\nINSERT INTO course VALUES('3-105', '计算机导论', '825');\nINSERT INTO course VALUES('3-245', '操作系统', '804');\nINSERT INTO course VALUES('6-166', '数字电路', '856');\nINSERT INTO course VALUES('9-888', '高等数学', '831');\n\n-- 添加添加成绩表数据\nINSERT INTO score VALUES('103', '3-105', '92');\nINSERT INTO score VALUES('103', '3-245', '86');\nINSERT INTO score VALUES('103', '6-166', '85');\nINSERT INTO score VALUES('105', '3-105', '88');\nINSERT INTO score VALUES('105', '3-245', '75');\nINSERT INTO score VALUES('105', '6-166', '79');\nINSERT INTO score VALUES('109', '3-105', '76');\nINSERT INTO score VALUES('109', '3-245', '68');\nINSERT INTO score VALUES('109', '6-166', '81');\n\n-- 查看表结构\nSELECT * FROM course;\nSELECT * FROM score;\nSELECT * FROM student;\nSELECT * FROM teacher;\n\n1 到 10-- 查询 student 表的所有行\nSELECT * FROM student;\n\n-- 查询 student 表中的 name、sex 和 class 字段的所有行\nSELECT name, sex, class FROM student;\n\n-- 查询 teacher 表中不重复的 department 列\n-- department: 去重查询\nSELECT DISTINCT department FROM teacher;\n\n-- 查询 score 表中成绩在60-80之间的所有行（区间查询和运算符查询）\n-- BETWEEN xx AND xx: 查询区间, AND 表示 \"并且\"\nSELECT * FROM score WHERE degree BETWEEN 60 AND 80;\nSELECT * FROM score WHERE degree > 60 AND degree &lt; 80;\n\n-- 查询 score 表中成绩为 85, 86 或 88 的行\n-- IN: 查询规定中的多个值\nSELECT * FROM score WHERE degree IN (85, 86, 88);\n\n-- 查询 student 表中 '95031' 班或性别为 '女' 的所有行\n-- or: 表示或者关系\nSELECT * FROM student WHERE class = '95031' or sex = '女';\n\n-- 以 class 降序的方式查询 student 表的所有行\n-- DESC: 降序，从高到低\n-- ASC（默认）: 升序，从低到高\nSELECT * FROM student ORDER BY class DESC;\nSELECT * FROM student ORDER BY class ASC;\n\n-- 以 c_no 升序、degree 降序查询 score 表的所有行\nSELECT * FROM score ORDER BY c_no ASC, degree DESC;\n\n-- 查询 \"95031\" 班的学生人数\n-- COUNT: 统计\nSELECT COUNT(*) FROM student WHERE class = '95031';\n\n-- 查询 score 表中的最高分的学生学号和课程编号（子查询或排序查询）。\n-- (SELECT MAX(degree) FROM score): 子查询，算出最高分\nSELECT s_no, c_no FROM score WHERE degree = (SELECT MAX(degree) FROM score);\n\n--  排序查询\n-- LIMIT r, n: 表示从第r行开始，查询n条数据\nSELECT s_no, c_no, degree FROM score ORDER BY degree DESC LIMIT 0, 1;\n\n分组计算平均成绩查询每门课的平均成绩。\n-- AVG: 平均值\nSELECT AVG(degree) FROM score WHERE c_no = '3-105';\nSELECT AVG(degree) FROM score WHERE c_no = '3-245';\nSELECT AVG(degree) FROM score WHERE c_no = '6-166';\n\n-- GROUP BY: 分组查询\nSELECT c_no, AVG(degree) FROM score GROUP BY c_no;\n\n分组条件与模糊查询查询 score 表中至少有 2 名学生选修，并以 3 开头的课程的平均分数。\nSELECT * FROM score;\n-- c_no 课程编号\n+------+-------+--------+\n| s_no | c_no  | degree |\n+------+-------+--------+\n| 103  | 3-105 |     92 |\n| 103  | 3-245 |     86 |\n| 103  | 6-166 |     85 |\n| 105  | 3-105 |     88 |\n| 105  | 3-245 |     75 |\n| 105  | 6-166 |     79 |\n| 109  | 3-105 |     76 |\n| 109  | 3-245 |     68 |\n| 109  | 6-166 |     81 |\n+------+-------+--------+\n\n分析表发现，至少有 2 名学生选修的课程是 3-105 、3-245 、6-166 ，以 3 开头的课程是 3-105 、3-245 。也就是说，我们要查询所有 3-105 和 3-245 的 degree 平均分。\n-- 首先把 c_no, AVG(degree) 通过分组查询出来\nSELECT c_no, AVG(degree) FROM score GROUP BY c_no\n+-------+-------------+\n| c_no  | AVG(degree) |\n+-------+-------------+\n| 3-105 |     85.3333 |\n| 3-245 |     76.3333 |\n| 6-166 |     81.6667 |\n+-------+-------------+\n\n-- 再查询出至少有 2 名学生选修的课程\n-- HAVING: 表示持有\nHAVING COUNT(c_no) >= 2\n\n-- 并且是以 3 开头的课程\n-- LIKE 表示模糊查询，\"%\" 是一个通配符，匹配 \"3\" 后面的任意字符。\nAND c_no LIKE '3%';\n\n-- 把前面的SQL语句拼接起来，\n-- 后面加上一个 COUNT(*)，表示将每个分组的个数也查询出来。\nSELECT c_no, AVG(degree), COUNT(*) FROM score GROUP BY c_no\nHAVING COUNT(c_no) >= 2 AND c_no LIKE '3%';\n+-------+-------------+----------+\n| c_no  | AVG(degree) | COUNT(*) |\n+-------+-------------+----------+\n| 3-105 |     85.3333 |        3 |\n| 3-245 |     76.3333 |        3 |\n+-------+-------------+----------+\n\n多表查询 - 1查询所有学生的 name，以及该学生在 score 表中对应的 c_no 和 degree 。\nSELECT no, name FROM student;\n+-----+-----------+\n| no  | name      |\n+-----+-----------+\n| 101 | 曾华      |\n| 102 | 匡明      |\n| 103 | 王丽      |\n| 104 | 李军      |\n| 105 | 王芳      |\n| 106 | 陆军      |\n| 107 | 王尼玛    |\n| 108 | 张全蛋    |\n| 109 | 赵铁柱    |\n+-----+-----------+\n\nSELECT s_no, c_no, degree FROM score;\n+------+-------+--------+\n| s_no | c_no  | degree |\n+------+-------+--------+\n| 103  | 3-105 |     92 |\n| 103  | 3-245 |     86 |\n| 103  | 6-166 |     85 |\n| 105  | 3-105 |     88 |\n| 105  | 3-245 |     75 |\n| 105  | 6-166 |     79 |\n| 109  | 3-105 |     76 |\n| 109  | 3-245 |     68 |\n| 109  | 6-166 |     81 |\n+------+-------+--------+\n\n通过分析可以发现，只要把 score 表中的 s_no 字段值替换成 student 表中对应的 name 字段值就可以了，如何做呢？\n-- FROM...: 表示从 student, score 表中查询\n-- WHERE 的条件表示为，只有在 student.no 和 score.s_no 相等时才显示出来。\nSELECT name, c_no, degree FROM student, score \nWHERE student.no = score.s_no;\n+-----------+-------+--------+\n| name      | c_no  | degree |\n+-----------+-------+--------+\n| 王丽      | 3-105 |     92 |\n| 王丽      | 3-245 |     86 |\n| 王丽      | 6-166 |     85 |\n| 王芳      | 3-105 |     88 |\n| 王芳      | 3-245 |     75 |\n| 王芳      | 6-166 |     79 |\n| 赵铁柱    | 3-105 |     76 |\n| 赵铁柱    | 3-245 |     68 |\n| 赵铁柱    | 6-166 |     81 |\n+-----------+-------+--------+\n\n多表查询 - 2查询所有学生的 no 、课程名称 ( course 表中的 name ) 和成绩 ( score 表中的 degree ) 列。\n只有 score 关联学生的 no ，因此只要查询 score 表，就能找出所有和学生相关的 no 和 degree ：\nSELECT s_no, c_no, degree FROM score;\n+------+-------+--------+\n| s_no | c_no  | degree |\n+------+-------+--------+\n| 103  | 3-105 |     92 |\n| 103  | 3-245 |     86 |\n| 103  | 6-166 |     85 |\n| 105  | 3-105 |     88 |\n| 105  | 3-245 |     75 |\n| 105  | 6-166 |     79 |\n| 109  | 3-105 |     76 |\n| 109  | 3-245 |     68 |\n| 109  | 6-166 |     81 |\n+------+-------+--------+\n\n然后查询 course 表：\n+-------+-----------------+\n| no    | name            |\n+-------+-----------------+\n| 3-105 | 计算机导论      |\n| 3-245 | 操作系统        |\n| 6-166 | 数字电路        |\n| 9-888 | 高等数学        |\n+-------+-----------------+\n\n只要把 score 表中的 c_no 替换成 course 表中对应的 name 字段值就可以了。\n-- 增加一个查询字段 name，分别从 score、course 这两个表中查询。\n-- as 表示取一个该字段的别名。\nSELECT s_no, name as c_name, degree FROM score, course\nWHERE score.c_no = course.no;\n+------+-----------------+--------+\n| s_no | c_name          | degree |\n+------+-----------------+--------+\n| 103  | 计算机导论      |     92 |\n| 105  | 计算机导论      |     88 |\n| 109  | 计算机导论      |     76 |\n| 103  | 操作系统        |     86 |\n| 105  | 操作系统        |     75 |\n| 109  | 操作系统        |     68 |\n| 103  | 数字电路        |     85 |\n| 105  | 数字电路        |     79 |\n| 109  | 数字电路        |     81 |\n+------+-----------------+--------+\n\n三表关联查询查询所有学生的 name 、课程名 ( course 表中的 name ) 和 degree 。\n只有 score 表中关联学生的学号和课堂号，我们只要围绕着 score 这张表查询就好了。\nSELECT * FROM score;\n+------+-------+--------+\n| s_no | c_no  | degree |\n+------+-------+--------+\n| 103  | 3-105 |     92 |\n| 103  | 3-245 |     86 |\n| 103  | 6-166 |     85 |\n| 105  | 3-105 |     88 |\n| 105  | 3-245 |     75 |\n| 105  | 6-166 |     79 |\n| 109  | 3-105 |     76 |\n| 109  | 3-245 |     68 |\n| 109  | 6-166 |     81 |\n+------+-------+--------+\n\n只要把 s_no 和 c_no 替换成 student 和 srouse 表中对应的 name 字段值就好了。\n首先把 s_no 替换成 student 表中的 name 字段：\nSELECT name, c_no, degree FROM student, score WHERE student.no = score.s_no;\n+-----------+-------+--------+\n| name      | c_no  | degree |\n+-----------+-------+--------+\n| 王丽      | 3-105 |     92 |\n| 王丽      | 3-245 |     86 |\n| 王丽      | 6-166 |     85 |\n| 王芳      | 3-105 |     88 |\n| 王芳      | 3-245 |     75 |\n| 王芳      | 6-166 |     79 |\n| 赵铁柱    | 3-105 |     76 |\n| 赵铁柱    | 3-245 |     68 |\n| 赵铁柱    | 6-166 |     81 |\n+-----------+-------+--------+\n\n再把 c_no 替换成 course 表中的 name 字段：\n-- 课程表\nSELECT no, name FROM course;\n+-------+-----------------+\n| no    | name            |\n+-------+-----------------+\n| 3-105 | 计算机导论      |\n| 3-245 | 操作系统        |\n| 6-166 | 数字电路        |\n| 9-888 | 高等数学        |\n+-------+-----------------+\n\n-- 由于字段名存在重复，使用 \"表名.字段名 as 别名\" 代替。\nSELECT student.name as s_name, course.name as c_name, degree \nFROM student, score, course\nWHERE student.NO = score.s_no\nAND score.c_no = course.no;\n\n子查询加分组求平均分查询 95031 班学生每门课程的平均成绩。\n在 score 表中根据 student  表的学生编号筛选出学生的课堂号和成绩：\n-- IN (..): 将筛选出的学生号当做 s_no 的条件查询\nSELECT s_no, c_no, degree FROM score\nWHERE s_no IN (SELECT no FROM student WHERE class = '95031');\n+------+-------+--------+\n| s_no | c_no  | degree |\n+------+-------+--------+\n| 105  | 3-105 |     88 |\n| 105  | 3-245 |     75 |\n| 105  | 6-166 |     79 |\n| 109  | 3-105 |     76 |\n| 109  | 3-245 |     68 |\n| 109  | 6-166 |     81 |\n+------+-------+--------+\n\n这时只要将 c_no 分组一下就能得出 95031 班学生每门课的平均成绩：\nSELECT c_no, AVG(degree) FROM score\nWHERE s_no IN (SELECT no FROM student WHERE class = '95031')\nGROUP BY c_no;\n+-------+-------------+\n| c_no  | AVG(degree) |\n+-------+-------------+\n| 3-105 |     82.0000 |\n| 3-245 |     71.5000 |\n| 6-166 |     80.0000 |\n+-------+-------------+\n\n子查询 - 1查询在 3-105 课程中，所有成绩高于 109 号同学的记录。\n首先筛选出课堂号为 3-105 ，在找出所有成绩高于 109 号同学的的行。\nSELECT * FROM score \nWHERE c_no = '3-105'\nAND degree > (SELECT degree FROM score WHERE s_no = '109' AND c_no = '3-105');\n\n子查询 - 2查询所有成绩高于 109 号同学的 3-105 课程成绩记录。\n-- 不限制课程号，只要成绩大于109号同学的3-105课程成绩就可以。\nSELECT * FROM score\nWHERE degree > (SELECT degree FROM score WHERE s_no = '109' AND c_no = '3-105');\n\nYEAR 函数与带 IN 关键字查询查询所有和 101 、108 号学生同年出生的 no 、name 、birthday 列。\n-- YEAR(..): 取出日期中的年份\nSELECT no, name, birthday FROM student\nWHERE YEAR(birthday) IN (SELECT YEAR(birthday) FROM student WHERE no IN (101, 108));\n\n多层嵌套子查询查询 &#39;张旭&#39; 教师任课的学生成绩表。\n首先找到教师编号：\nSELECT NO FROM teacher WHERE NAME = '张旭'\n\n通过 sourse 表找到该教师课程号：\nSELECT NO FROM course WHERE t_no = ( SELECT NO FROM teacher WHERE NAME = '张旭' );\n\n通过筛选出的课程号查询成绩表：\nSELECT * FROM score WHERE c_no = (\n    SELECT no FROM course WHERE t_no = ( \n        SELECT no FROM teacher WHERE NAME = '张旭' \n    )\n);\n\n多表查询查询某选修课程多于5个同学的教师姓名。\n首先在 teacher 表中，根据 no 字段来判断该教师的同一门课程是否有至少5名学员选修：\n-- 查询 teacher 表\nSELECT no, name FROM teacher;\n+-----+--------+\n| no  | name   |\n+-----+--------+\n| 804 | 李诚   |\n| 825 | 王萍   |\n| 831 | 刘冰   |\n| 856 | 张旭   |\n+-----+--------+\n\nSELECT name FROM teacher WHERE no IN (\n    -- 在这里找到对应的条件\n);\n\n查看和教师编号有有关的表的信息：\nSELECT * FROM course;\n-- t_no: 教师编号\n+-------+-----------------+------+\n| no    | name            | t_no |\n+-------+-----------------+------+\n| 3-105 | 计算机导论      | 825  |\n| 3-245 | 操作系统        | 804  |\n| 6-166 | 数字电路        | 856  |\n| 9-888 | 高等数学        | 831  |\n+-------+-----------------+------+\n\n我们已经找到和教师编号有关的字段就在 course 表中，但是还无法知道哪门课程至少有5名学生选修，所以还需要根据 score 表来查询：\n-- 在此之前向 score 插入一些数据，以便丰富查询条件。\nINSERT INTO score VALUES ('101', '3-105', '90');\nINSERT INTO score VALUES ('102', '3-105', '91');\nINSERT INTO score VALUES ('104', '3-105', '89');\n\n-- 查询 score 表\nSELECT * FROM score;\n+------+-------+--------+\n| s_no | c_no  | degree |\n+------+-------+--------+\n| 101  | 3-105 |     90 |\n| 102  | 3-105 |     91 |\n| 103  | 3-105 |     92 |\n| 103  | 3-245 |     86 |\n| 103  | 6-166 |     85 |\n| 104  | 3-105 |     89 |\n| 105  | 3-105 |     88 |\n| 105  | 3-245 |     75 |\n| 105  | 6-166 |     79 |\n| 109  | 3-105 |     76 |\n| 109  | 3-245 |     68 |\n| 109  | 6-166 |     81 |\n+------+-------+--------+\n\n-- 在 score 表中将 c_no 作为分组，并且限制 c_no 持有至少 5 条数据。\nSELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) > 5;\n+-------+\n| c_no  |\n+-------+\n| 3-105 |\n+-------+\n\n根据筛选出来的课程号，找出在某课程中，拥有至少5名学员的教师编号：\nSELECT t_no FROM course WHERE no IN (\n    SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) > 5\n);\n+------+\n| t_no |\n+------+\n| 825  |\n+------+\n\n在 teacher 表中，根据筛选出来的教师编号找到教师姓名：\nSELECT name FROM teacher WHERE no IN (\n    -- 最终条件\n    SELECT t_no FROM course WHERE no IN (\n        SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) > 5\n    )\n);\n\n子查询 - 3查询 “计算机系” 课程的成绩表。\n思路是，先找出 course 表中所有 计算机系 课程的编号，然后根据这个编号查询 score 表。\n-- 通过 teacher 表查询所有 `计算机系` 的教师编号\nSELECT no, name, department FROM teacher WHERE department = '计算机系'\n+-----+--------+--------------+\n| no  | name   | department   |\n+-----+--------+--------------+\n| 804 | 李诚   | 计算机系     |\n| 825 | 王萍   | 计算机系     |\n+-----+--------+--------------+\n\n-- 通过 course 表查询该教师的课程编号\nSELECT no FROM course WHERE t_no IN (\n    SELECT no FROM teacher WHERE department = '计算机系'\n);\n+-------+\n| no    |\n+-------+\n| 3-245 |\n| 3-105 |\n+-------+\n\n-- 根据筛选出来的课程号查询成绩表\nSELECT * FROM score WHERE c_no IN (\n    SELECT no FROM course WHERE t_no IN (\n        SELECT no FROM teacher WHERE department = '计算机系'\n    )\n);\n+------+-------+--------+\n| s_no | c_no  | degree |\n+------+-------+--------+\n| 103  | 3-245 |     86 |\n| 105  | 3-245 |     75 |\n| 109  | 3-245 |     68 |\n| 101  | 3-105 |     90 |\n| 102  | 3-105 |     91 |\n| 103  | 3-105 |     92 |\n| 104  | 3-105 |     89 |\n| 105  | 3-105 |     88 |\n| 109  | 3-105 |     76 |\n+------+-------+--------+\n\nUNION 和 NOTIN 的使用查询 计算机系 与 电子工程系 中的不同职称的教师。\n-- NOT: 代表逻辑非\nSELECT * FROM teacher WHERE department = '计算机系' AND profession NOT IN (\n    SELECT profession FROM teacher WHERE department = '电子工程系'\n)\n-- 合并两个集\nUNION\nSELECT * FROM teacher WHERE department = '电子工程系' AND profession NOT IN (\n    SELECT profession FROM teacher WHERE department = '计算机系'\n);\n\nANY 表示至少一个 - DESC ( 降序 )查询课程 3-105 且成绩 至少 高于 3-245 的 score 表。\nSELECT * FROM score WHERE c_no = '3-105';\n+------+-------+--------+\n| s_no | c_no  | degree |\n+------+-------+--------+\n| 101  | 3-105 |     90 |\n| 102  | 3-105 |     91 |\n| 103  | 3-105 |     92 |\n| 104  | 3-105 |     89 |\n| 105  | 3-105 |     88 |\n| 109  | 3-105 |     76 |\n+------+-------+--------+\n\nSELECT * FROM score WHERE c_no = '3-245';\n+------+-------+--------+\n| s_no | c_no  | degree |\n+------+-------+--------+\n| 103  | 3-245 |     86 |\n| 105  | 3-245 |     75 |\n| 109  | 3-245 |     68 |\n+------+-------+--------+\n\n-- ANY: 符合SQL语句中的任意条件。\n-- 也就是说，在 3-105 成绩中，只要有一个大于从 3-245 筛选出来的任意行就符合条件，\n-- 最后根据降序查询结果。\nSELECT * FROM score WHERE c_no = '3-105' AND degree > ANY(\n    SELECT degree FROM score WHERE c_no = '3-245'\n) ORDER BY degree DESC;\n+------+-------+--------+\n| s_no | c_no  | degree |\n+------+-------+--------+\n| 103  | 3-105 |     92 |\n| 102  | 3-105 |     91 |\n| 101  | 3-105 |     90 |\n| 104  | 3-105 |     89 |\n| 105  | 3-105 |     88 |\n| 109  | 3-105 |     76 |\n+------+-------+--------+\n\n表示所有的 ALL查询课程 3-105 且成绩高于 3-245 的 score 表。\n-- 只需对上一道题稍作修改。\n-- ALL: 符合SQL语句中的所有条件。\n-- 也就是说，在 3-105 每一行成绩中，都要大于从 3-245 筛选出来全部行才算符合条件。\nSELECT * FROM score WHERE c_no = '3-105' AND degree > ALL(\n    SELECT degree FROM score WHERE c_no = '3-245'\n);\n+------+-------+--------+\n| s_no | c_no  | degree |\n+------+-------+--------+\n| 101  | 3-105 |     90 |\n| 102  | 3-105 |     91 |\n| 103  | 3-105 |     92 |\n| 104  | 3-105 |     89 |\n| 105  | 3-105 |     88 |\n+------+-------+--------+\n\n复制表的数据作为条件查询查询某课程成绩比该课程平均成绩低的 score 表。\n-- 查询平均分\nSELECT c_no, AVG(degree) FROM score GROUP BY c_no;\n+-------+-------------+\n| c_no  | AVG(degree) |\n+-------+-------------+\n| 3-105 |     87.6667 |\n| 3-245 |     76.3333 |\n| 6-166 |     81.6667 |\n+-------+-------------+\n\n-- 查询 score 表\nSELECT degree FROM score;\n+--------+\n| degree |\n+--------+\n|     90 |\n|     91 |\n|     92 |\n|     86 |\n|     85 |\n|     89 |\n|     88 |\n|     75 |\n|     79 |\n|     76 |\n|     68 |\n|     81 |\n+--------+\n\n-- 将表 b 作用于表 a 中查询数据\n-- score a (b): 将表声明为 a (b)，\n-- 如此就能用 a.c_no = b.c_no 作为条件执行查询了。\nSELECT * FROM score a WHERE degree &lt; (\n    (SELECT AVG(degree) FROM score b WHERE a.c_no = b.c_no)\n);\n+------+-------+--------+\n| s_no | c_no  | degree |\n+------+-------+--------+\n| 105  | 3-245 |     75 |\n| 105  | 6-166 |     79 |\n| 109  | 3-105 |     76 |\n| 109  | 3-245 |     68 |\n| 109  | 6-166 |     81 |\n+------+-------+--------+\n\n子查询 - 4查询所有任课 ( 在 course 表里有课程 ) 教师的 name 和 department 。\nSELECT name, department FROM teacher WHERE no IN (SELECT t_no FROM course);\n+--------+-----------------+\n| name   | department      |\n+--------+-----------------+\n| 李诚   | 计算机系        |\n| 王萍   | 计算机系        |\n| 刘冰   | 电子工程系      |\n| 张旭   | 电子工程系      |\n+--------+-----------------+\n\n条件加组筛选查询 student 表中至少有 2 名男生的 class 。\n-- 查看学生表信息\nSELECT * FROM student;\n+-----+-----------+-----+------------+-------+\n| no  | name      | sex | birthday   | class |\n+-----+-----------+-----+------------+-------+\n| 101 | 曾华      | 男  | 1977-09-01 | 95033 |\n| 102 | 匡明      | 男  | 1975-10-02 | 95031 |\n| 103 | 王丽      | 女  | 1976-01-23 | 95033 |\n| 104 | 李军      | 男  | 1976-02-20 | 95033 |\n| 105 | 王芳      | 女  | 1975-02-10 | 95031 |\n| 106 | 陆军      | 男  | 1974-06-03 | 95031 |\n| 107 | 王尼玛    | 男  | 1976-02-20 | 95033 |\n| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |\n| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |\n| 110 | 张飞      | 男  | 1974-06-03 | 95038 |\n+-----+-----------+-----+------------+-------+\n\n-- 只查询性别为男，然后按 class 分组，并限制 class 行大于 1。\nSELECT class FROM student WHERE sex = '男' GROUP BY class HAVING COUNT(*) > 1;\n+-------+\n| class |\n+-------+\n| 95033 |\n| 95031 |\n+-------+\n\nNOTLIKE 模糊查询取反查询 student 表中不姓 “王” 的同学记录。\n-- NOT: 取反\n-- LIKE: 模糊查询\nsql> SELECT * FROM student WHERE name NOT LIKE '王%';\n+-----+-----------+-----+------------+-------+\n| no  | name      | sex | birthday   | class |\n+-----+-----------+-----+------------+-------+\n| 101 | 曾华      | 男  | 1977-09-01 | 95033 |\n| 102 | 匡明      | 男  | 1975-10-02 | 95031 |\n| 104 | 李军      | 男  | 1976-02-20 | 95033 |\n| 106 | 陆军      | 男  | 1974-06-03 | 95031 |\n| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |\n| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |\n| 110 | 张飞      | 男  | 1974-06-03 | 95038 |\n+-----+-----------+-----+------------+-------+\n\nYEAR 与 NOW 函数查询 student 表中每个学生的姓名和年龄。\n-- 使用函数 YEAR(NOW()) 计算出当前年份，减去出生年份后得出年龄。\nSELECT name, YEAR(NOW()) - YEAR(birthday) as age FROM student;\n+-----------+------+\n| name      | age  |\n+-----------+------+\n| 曾华      |   42 |\n| 匡明      |   44 |\n| 王丽      |   43 |\n| 李军      |   43 |\n| 王芳      |   44 |\n| 陆军      |   45 |\n| 王尼玛    |   43 |\n| 张全蛋    |   44 |\n| 赵铁柱    |   45 |\n| 张飞      |   45 |\n+-----------+------+\n\nMAX 与 MIN 函数查询 student 表中最大和最小的 birthday 值。\nSELECT MAX(birthday), MIN(birthday) FROM student;\n+---------------+---------------+\n| MAX(birthday) | MIN(birthday) |\n+---------------+---------------+\n| 1977-09-01    | 1974-06-03    |\n+---------------+---------------+\n\n多段排序以 class 和 birthday 从大到小的顺序查询 student 表。\nSELECT * FROM student ORDER BY class DESC, birthday;\n+-----+-----------+-----+------------+-------+\n| no  | name      | sex | birthday   | class |\n+-----+-----------+-----+------------+-------+\n| 110 | 张飞      | 男  | 1974-06-03 | 95038 |\n| 103 | 王丽      | 女  | 1976-01-23 | 95033 |\n| 104 | 李军      | 男  | 1976-02-20 | 95033 |\n| 107 | 王尼玛    | 男  | 1976-02-20 | 95033 |\n| 101 | 曾华      | 男  | 1977-09-01 | 95033 |\n| 106 | 陆军      | 男  | 1974-06-03 | 95031 |\n| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |\n| 105 | 王芳      | 女  | 1975-02-10 | 95031 |\n| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |\n| 102 | 匡明      | 男  | 1975-10-02 | 95031 |\n+-----+-----------+-----+------------+-------+\n\n子查询 - 5查询 “男” 教师及其所上的课程。\nSELECT * FROM course WHERE t_no in (SELECT no FROM teacher WHERE sex = '男');\n+-------+--------------+------+\n| no    | name         | t_no |\n+-------+--------------+------+\n| 3-245 | 操作系统     | 804  |\n| 6-166 | 数字电路     | 856  |\n+-------+--------------+------+\n\nMAX 函数与子查询查询最高分同学的 score 表。\n-- 找出最高成绩（该查询只能有一个结果）\nSELECT MAX(degree) FROM score;\n\n-- 根据上面的条件筛选出所有最高成绩表，\n-- 该查询可能有多个结果，假设 degree 值多次符合条件。\nSELECT * FROM score WHERE degree = (SELECT MAX(degree) FROM score);\n+------+-------+--------+\n| s_no | c_no  | degree |\n+------+-------+--------+\n| 103  | 3-105 |     92 |\n+------+-------+--------+\n\n子查询 - 6查询和 “李军” 同性别的所有同学 name 。\n-- 首先将李军的性别作为条件取出来\nSELECT sex FROM student WHERE name = '李军';\n+-----+\n| sex |\n+-----+\n| 男  |\n+-----+\n\n-- 根据性别查询 name 和 sex\nSELECT name, sex FROM student WHERE sex = (\n    SELECT sex FROM student WHERE name = '李军'\n);\n+-----------+-----+\n| name      | sex |\n+-----------+-----+\n| 曾华      | 男  |\n| 匡明      | 男  |\n| 李军      | 男  |\n| 陆军      | 男  |\n| 王尼玛    | 男  |\n| 张全蛋    | 男  |\n| 赵铁柱    | 男  |\n| 张飞      | 男  |\n+-----------+-----+\n\n子查询 - 7查询和 “李军” 同性别且同班的同学 name 。\nSELECT name, sex, class FROM student WHERE sex = (\n    SELECT sex FROM student WHERE name = '李军'\n) AND class = (\n    SELECT class FROM student WHERE name = '李军'\n);\n+-----------+-----+-------+\n| name      | sex | class |\n+-----------+-----+-------+\n| 曾华      | 男  | 95033 |\n| 李军      | 男  | 95033 |\n| 王尼玛    | 男  | 95033 |\n+-----------+-----+-------+\n\n子查询 - 8查询所有选修 “计算机导论” 课程的 “男” 同学成绩表。\n需要的 “计算机导论” 和性别为 “男” 的编号可以在 course 和 student 表中找到。\nSELECT * FROM score WHERE c_no = (\n    SELECT no FROM course WHERE name = '计算机导论'\n) AND s_no IN (\n    SELECT no FROM student WHERE sex = '男'\n);\n+------+-------+--------+\n| s_no | c_no  | degree |\n+------+-------+--------+\n| 101  | 3-105 |     90 |\n| 102  | 3-105 |     91 |\n| 104  | 3-105 |     89 |\n| 109  | 3-105 |     76 |\n+------+-------+--------+\n\n按等级查询建立一个 grade 表代表学生的成绩等级，并插入数据：\nCREATE TABLE grade (\n    low INT(3),\n    upp INT(3),\n    grade char(1)\n);\n\nINSERT INTO grade VALUES (90, 100, 'A');\nINSERT INTO grade VALUES (80, 89, 'B');\nINSERT INTO grade VALUES (70, 79, 'C');\nINSERT INTO grade VALUES (60, 69, 'D');\nINSERT INTO grade VALUES (0, 59, 'E');\n\nSELECT * FROM grade;\n+------+------+-------+\n| low  | upp  | grade |\n+------+------+-------+\n|   90 |  100 | A     |\n|   80 |   89 | B     |\n|   70 |   79 | C     |\n|   60 |   69 | D     |\n|    0 |   59 | E     |\n+------+------+-------+\n\n查询所有学生的 s_no 、c_no 和 grade 列。\n思路是，使用区间 ( BETWEEN ) 查询，判断学生的成绩 ( degree )  在 grade 表的 low 和 upp 之间。\nSELECT s_no, c_no, grade FROM score, grade \nWHERE degree BETWEEN low AND upp;\n+------+-------+-------+\n| s_no | c_no  | grade |\n+------+-------+-------+\n| 101  | 3-105 | A     |\n| 102  | 3-105 | A     |\n| 103  | 3-105 | A     |\n| 103  | 3-245 | B     |\n| 103  | 6-166 | B     |\n| 104  | 3-105 | B     |\n| 105  | 3-105 | B     |\n| 105  | 3-245 | C     |\n| 105  | 6-166 | C     |\n| 109  | 3-105 | C     |\n| 109  | 3-245 | D     |\n| 109  | 6-166 | B     |\n+------+-------+-------+\n\n连接查询准备用于测试连接查询的数据：\nCREATE DATABASE testJoin;\n\nCREATE TABLE person (\n    id INT,\n    name VARCHAR(20),\n    cardId INT\n);\n\nCREATE TABLE card (\n    id INT,\n    name VARCHAR(20)\n);\n\nINSERT INTO card VALUES (1, '饭卡'), (2, '建行卡'), (3, '农行卡'), (4, '工商卡'), (5, '邮政卡');\nSELECT * FROM card;\n+------+-----------+\n| id   | name      |\n+------+-----------+\n|    1 | 饭卡      |\n|    2 | 建行卡    |\n|    3 | 农行卡    |\n|    4 | 工商卡    |\n|    5 | 邮政卡    |\n+------+-----------+\n\nINSERT INTO person VALUES (1, '张三', 1), (2, '李四', 3), (3, '王五', 6);\nSELECT * FROM person;\n+------+--------+--------+\n| id   | name   | cardId |\n+------+--------+--------+\n|    1 | 张三   |      1 |\n|    2 | 李四   |      3 |\n|    3 | 王五   |      6 |\n+------+--------+--------+\n\n分析两张表发现，person 表并没有为 cardId 字段设置一个在 card 表中对应的 id 外键。如果设置了的话，person 中 cardId 字段值为 6 的行就插不进去，因为该 cardId 值在 card 表中并没有。\n内连接要查询这两张表中有关系的数据，可以使用 INNER JOIN ( 内连接 ) 将它们连接在一起。\n-- INNER JOIN: 表示为内连接，将两张表拼接在一起。\n-- on: 表示要执行某个条件。\nSELECT * FROM person INNER JOIN card on person.cardId = card.id;\n+------+--------+--------+------+-----------+\n| id   | name   | cardId | id   | name      |\n+------+--------+--------+------+-----------+\n|    1 | 张三   |      1 |    1 | 饭卡      |\n|    2 | 李四   |      3 |    3 | 农行卡    |\n+------+--------+--------+------+-----------+\n\n-- 将 INNER 关键字省略掉，结果也是一样的。\n-- SELECT * FROM person JOIN card on person.cardId = card.id;\n\n\n\n\n\n\n\n\n\n\n注意：card 的整张表被连接到了右边。\n左外连接完整显示左边的表 ( person ) ，右边的表如果符合条件就显示，不符合则补 NULL 。\n-- LEFT JOIN 也叫做 LEFT OUTER JOIN，用这两种方式的查询结果是一样的。\nSELECT * FROM person LEFT JOIN card on person.cardId = card.id;\n+------+--------+--------+------+-----------+\n| id   | name   | cardId | id   | name      |\n+------+--------+--------+------+-----------+\n|    1 | 张三   |      1 |    1 | 饭卡      |\n|    2 | 李四   |      3 |    3 | 农行卡    |\n|    3 | 王五   |      6 | NULL | NULL      |\n+------+--------+--------+------+-----------+\n\n右外链接完整显示右边的表 ( card ) ，左边的表如果符合条件就显示，不符合则补 NULL 。\nSELECT * FROM person RIGHT JOIN card on person.cardId = card.id;\n+------+--------+--------+------+-----------+\n| id   | name   | cardId | id   | name      |\n+------+--------+--------+------+-----------+\n|    1 | 张三   |      1 |    1 | 饭卡      |\n|    2 | 李四   |      3 |    3 | 农行卡    |\n| NULL | NULL   |   NULL |    2 | 建行卡    |\n| NULL | NULL   |   NULL |    4 | 工商卡    |\n| NULL | NULL   |   NULL |    5 | 邮政卡    |\n+------+--------+--------+------+-----------+\n\n全外链接完整显示两张表的全部数据。\n-- sql 不支持这种语法的全外连接\n-- SELECT * FROM person FULL JOIN card on person.cardId = card.id;\n-- 出现错误：\n-- ERROR 1054 (42S22): Unknown column 'person.cardId' in 'on clause'\n\n-- sql全连接语法，使用 UNION 将两张表合并在一起。\nSELECT * FROM person LEFT JOIN card on person.cardId = card.id\nUNION\nSELECT * FROM person RIGHT JOIN card on person.cardId = card.id;\n+------+--------+--------+------+-----------+\n| id   | name   | cardId | id   | name      |\n+------+--------+--------+------+-----------+\n|    1 | 张三   |      1 |    1 | 饭卡      |\n|    2 | 李四   |      3 |    3 | 农行卡    |\n|    3 | 王五   |      6 | NULL | NULL      |\n| NULL | NULL   |   NULL |    2 | 建行卡    |\n| NULL | NULL   |   NULL |    4 | 工商卡    |\n| NULL | NULL   |   NULL |    5 | 邮政卡    |\n+------+--------+--------+------+-----------+\n\n事务在 sql 中，事务其实是一个最小的不可分割的工作单元。事务能够保证一个业务的完整性。\n比如我们的银行转账：\n-- a -> -100\nUPDATE user set money = money - 100 WHERE name = 'a';\n\n-- b -> +100\nUPDATE user set money = money + 100 WHERE name = 'b';\n\n在实际项目中，假设只有一条 SQL 语句执行成功，而另外一条执行失败了，就会出现数据前后不一致。\n因此，在执行多条有关联 SQL 语句时，事务可能会要求这些 SQL 语句要么同时执行成功，要么就都执行失败。\n如何控制事务 - COMMIT / ROLLBACK在 sql 中，事务的自动提交状态默认是开启的。\n-- 查询事务的自动提交状态\nSELECT @@AUTOCOMMIT;\n+--------------+\n| @@AUTOCOMMIT |\n+--------------+\n|            1 |\n+--------------+\n\n自动提交的作用：当我们执行一条 SQL 语句的时候，其产生的效果就会立即体现出来，且不能回滚。\n什么是回滚？举个例子：\nCREATE DATABASE bank;\n\nUSE bank;\n\nCREATE TABLE user (\n    id INT PRIMARY KEY,\n    name VARCHAR(20),\n    money INT\n);\n\nINSERT INTO user VALUES (1, 'a', 1000);\n\nSELECT * FROM user;\n+----+------+-------+\n| id | name | money |\n+----+------+-------+\n|  1 | a    |  1000 |\n+----+------+-------+\n\n可以看到，在执行插入语句后数据立刻生效，原因是 sql 中的事务自动将它提交到了数据库中。那么所谓回滚的意思就是，撤销执行过的所有 SQL 语句，使其回滚到最后一次提交数据时的状态。\n在 sql 中使用 ROLLBACK 执行回滚：\n-- 回滚到最后一次提交\nROLLBACK;\n\nSELECT * FROM user;\n+----+------+-------+\n| id | name | money |\n+----+------+-------+\n|  1 | a    |  1000 |\n+----+------+-------+\n\n由于所有执行过的 SQL 语句都已经被提交过了，所以数据并没有发生回滚。那如何让数据可以发生回滚？\n-- 关闭自动提交\nSET AUTOCOMMIT = 0;\n\n-- 查询自动提交状态\nSELECT @@AUTOCOMMIT;\n+--------------+\n| @@AUTOCOMMIT |\n+--------------+\n|            0 |\n+--------------+\n\n将自动提交关闭后，测试数据回滚：\nINSERT INTO user VALUES (2, 'b', 1000);\n\n-- 关闭 AUTOCOMMIT 后，数据的变化是在一张虚拟的临时数据表中展示，\n-- 发生变化的数据并没有真正插入到数据表中。\nSELECT * FROM user;\n+----+------+-------+\n| id | name | money |\n+----+------+-------+\n|  1 | a    |  1000 |\n|  2 | b    |  1000 |\n+----+------+-------+\n\n-- 数据表中的真实数据其实还是：\n+----+------+-------+\n| id | name | money |\n+----+------+-------+\n|  1 | a    |  1000 |\n+----+------+-------+\n\n-- 由于数据还没有真正提交，可以使用回滚\nROLLBACK;\n\n-- 再次查询\nSELECT * FROM user;\n+----+------+-------+\n| id | name | money |\n+----+------+-------+\n|  1 | a    |  1000 |\n+----+------+-------+\n\n那如何将虚拟的数据真正提交到数据库中？使用 COMMIT : \nINSERT INTO user VALUES (2, 'b', 1000);\n-- 手动提交数据（持久性），\n-- 将数据真正提交到数据库中，执行后不能再回滚提交过的数据。\nCOMMIT;\n\n-- 提交后测试回滚\nROLLBACK;\n\n-- 再次查询（回滚无效了）\nSELECT * FROM user;\n+----+------+-------+\n| id | name | money |\n+----+------+-------+\n|  1 | a    |  1000 |\n|  2 | b    |  1000 |\n+----+------+-------+\n\n\n\n\n\n\n\n\n\n\n总结\n\n自动提交\n\n查看自动提交状态：SELECT @@AUTOCOMMIT ；\n\n设置自动提交状态：SET AUTOCOMMIT = 0 。\n\n\n\n手动提交\n@@AUTOCOMMIT = 0 时，使用 COMMIT 命令提交事务。\n\n事务回滚\n@@AUTOCOMMIT = 0 时，使用 ROLLBACK 命令回滚事务。\n\n\n事务的实际应用，让我们再回到银行转账项目：\n-- 转账\nUPDATE user set money = money - 100 WHERE name = 'a';\n\n-- 到账\nUPDATE user set money = money + 100 WHERE name = 'b';\n\nSELECT * FROM user;\n+----+------+-------+\n| id | name | money |\n+----+------+-------+\n|  1 | a    |   900 |\n|  2 | b    |  1100 |\n+----+------+-------+\n\n这时假设在转账时发生了意外，就可以使用 ROLLBACK 回滚到最后一次提交的状态：\n-- 假设转账发生了意外，需要回滚。\nROLLBACK;\n\nSELECT * FROM user;\n+----+------+-------+\n| id | name | money |\n+----+------+-------+\n|  1 | a    |  1000 |\n|  2 | b    |  1000 |\n+----+------+-------+\n\n这时我们又回到了发生意外之前的状态，也就是说，事务给我们提供了一个可以反悔的机会。假设数据没有发生意外，这时可以手动将数据真正提交到数据表中：COMMIT 。\n手动开启事务 - BEGIN / START TRANSACTION事务的默认提交被开启 ( @@AUTOCOMMIT = 1 ) 后，此时就不能使用事务回滚了。但是我们还可以手动开启一个事务处理事件，使其可以发生回滚：\n-- 使用 BEGIN 或者 START TRANSACTION 手动开启一个事务\n-- START TRANSACTION;\nBEGIN;\nUPDATE user set money = money - 100 WHERE name = 'a';\nUPDATE user set money = money + 100 WHERE name = 'b';\n\n-- 由于手动开启的事务没有开启自动提交，\n-- 此时发生变化的数据仍然是被保存在一张临时表中。\nSELECT * FROM user;\n+----+------+-------+\n| id | name | money |\n+----+------+-------+\n|  1 | a    |   900 |\n|  2 | b    |  1100 |\n+----+------+-------+\n\n-- 测试回滚\nROLLBACK;\n\nSELECT * FROM user;\n+----+------+-------+\n| id | name | money |\n+----+------+-------+\n|  1 | a    |  1000 |\n|  2 | b    |  1000 |\n+----+------+-------+\n\n仍然使用 COMMIT 提交数据，提交后无法再发生本次事务的回滚。\nBEGIN;\nUPDATE user set money = money - 100 WHERE name = 'a';\nUPDATE user set money = money + 100 WHERE name = 'b';\n\nSELECT * FROM user;\n+----+------+-------+\n| id | name | money |\n+----+------+-------+\n|  1 | a    |   900 |\n|  2 | b    |  1100 |\n+----+------+-------+\n\n-- 提交数据\nCOMMIT;\n\n-- 测试回滚（无效，因为表的数据已经被提交）\nROLLBACK;\n\n事务的 ACID 特征与使用事务的四大特征：\n\nA 原子性：事务是最小的单位，不可以再分割；\nC 一致性：要求同一事务中的 SQL 语句，必须保证同时成功或者失败；\nI 隔离性：事务1 和 事务2 之间是具有隔离性的；\nD 持久性：事务一旦结束 ( COMMIT ) ，就不可以再返回了 ( ROLLBACK ) 。\n\n事务的隔离性事务的隔离性可分为四种 ( 性能从低到高 ) ：\n\nREAD UNCOMMITTED ( 读取未提交 )\n如果有多个事务，那么任意事务都可以看见其他事务的未提交数据。\n\nREAD COMMITTED ( 读取已提交 )\n只能读取到其他事务已经提交的数据。\n\nREPEATABLE READ ( 可被重复读 )\n如果有多个连接都开启了事务，那么事务之间不能共享数据记录，否则只能共享已提交的记录。\n\nSERIALIZABLE ( 串行化 )\n所有的事务都会按照固定顺序执行，执行完一个事务后再继续执行下一个事务的写入操作。\n\n\n查看当前数据库的默认隔离级别：\n-- sql 8.x, GLOBAL 表示系统级别，不加表示会话级别。\nSELECT @@GLOBAL.TRANSACTION_ISOLATION;\nSELECT @@TRANSACTION_ISOLATION;\n+--------------------------------+\n| @@GLOBAL.TRANSACTION_ISOLATION |\n+--------------------------------+\n| REPEATABLE-READ                | -- sql的默认隔离级别，可以重复读。\n+--------------------------------+\n\n-- sql 5.x\nSELECT @@GLOBAL.TX_ISOLATION;\nSELECT @@TX_ISOLATION;\n\n修改隔离级别：\n-- 设置系统隔离级别，LEVEL 后面表示要设置的隔离级别 (READ UNCOMMITTED)。\nSET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\n\n-- 查询系统隔离级别，发现已经被修改。\nSELECT @@GLOBAL.TRANSACTION_ISOLATION;\n+--------------------------------+\n| @@GLOBAL.TRANSACTION_ISOLATION |\n+--------------------------------+\n| READ-UNCOMMITTED               |\n+--------------------------------+\n\n脏读测试 READ UNCOMMITTED ( 读取未提交 ) 的隔离性：\nINSERT INTO user VALUES (3, '小明', 1000);\nINSERT INTO user VALUES (4, '淘宝店', 1000);\n\nSELECT * FROM user;\n+----+-----------+-------+\n| id | name      | money |\n+----+-----------+-------+\n|  1 | a         |   900 |\n|  2 | b         |  1100 |\n|  3 | 小明      |  1000 |\n|  4 | 淘宝店    |  1000 |\n+----+-----------+-------+\n\n-- 开启一个事务操作数据\n-- 假设小明在淘宝店买了一双800块钱的鞋子：\nSTART TRANSACTION;\nUPDATE user SET money = money - 800 WHERE name = '小明';\nUPDATE user SET money = money + 800 WHERE name = '淘宝店';\n\n-- 然后淘宝店在另一方查询结果，发现钱已到账。\nSELECT * FROM user;\n+----+-----------+-------+\n| id | name      | money |\n+----+-----------+-------+\n|  1 | a         |   900 |\n|  2 | b         |  1100 |\n|  3 | 小明      |   200 |\n|  4 | 淘宝店    |  1800 |\n+----+-----------+-------+\n\n由于小明的转账是在新开启的事务上进行操作的，而该操作的结果是可以被其他事务（另一方的淘宝店）看见的，因此淘宝店的查询结果是正确的，淘宝店确认到账。但就在这时，如果小明在它所处的事务上又执行了 ROLLBACK 命令，会发生什么？\n-- 小明所处的事务\nROLLBACK;\n\n-- 此时无论对方是谁，如果再去查询结果就会发现：\nSELECT * FROM user;\n+----+-----------+-------+\n| id | name      | money |\n+----+-----------+-------+\n|  1 | a         |   900 |\n|  2 | b         |  1100 |\n|  3 | 小明      |  1000 |\n|  4 | 淘宝店    |  1000 |\n+----+-----------+-------+\n\n这就是所谓的脏读，一个事务读取到另外一个事务还未提交的数据。这在实际开发中是不允许出现的。\n读取已提交把隔离级别设置为 READ COMMITTED ：\nSET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;\nSELECT @@GLOBAL.TRANSACTION_ISOLATION;\n+--------------------------------+\n| @@GLOBAL.TRANSACTION_ISOLATION |\n+--------------------------------+\n| READ-COMMITTED                 |\n+--------------------------------+\n\n这样，再有新的事务连接进来时，它们就只能查询到已经提交过的事务数据了。但是对于当前事务来说，它们看到的还是未提交的数据，例如：\n-- 正在操作数据事务（当前事务）\nSTART TRANSACTION;\nUPDATE user SET money = money - 800 WHERE name = '小明';\nUPDATE user SET money = money + 800 WHERE name = '淘宝店';\n\n-- 虽然隔离级别被设置为了 READ COMMITTED，但在当前事务中，\n-- 它看到的仍然是数据表中临时改变数据，而不是真正提交过的数据。\nSELECT * FROM user;\n+----+-----------+-------+\n| id | name      | money |\n+----+-----------+-------+\n|  1 | a         |   900 |\n|  2 | b         |  1100 |\n|  3 | 小明      |   200 |\n|  4 | 淘宝店    |  1800 |\n+----+-----------+-------+\n\n\n-- 假设此时在远程开启了一个新事务，连接到数据库。\n$ sql -u root -p12345612\n\n-- 此时远程连接查询到的数据只能是已经提交过的\nSELECT * FROM user;\n+----+-----------+-------+\n| id | name      | money |\n+----+-----------+-------+\n|  1 | a         |   900 |\n|  2 | b         |  1100 |\n|  3 | 小明      |  1000 |\n|  4 | 淘宝店    |  1000 |\n+----+-----------+-------+\n\n但是这样还有问题，那就是假设一个事务在操作数据时，其他事务干扰了这个事务的数据。例如：\n-- 小张在查询数据的时候发现：\nSELECT * FROM user;\n+----+-----------+-------+\n| id | name      | money |\n+----+-----------+-------+\n|  1 | a         |   900 |\n|  2 | b         |  1100 |\n|  3 | 小明      |   200 |\n|  4 | 淘宝店    |  1800 |\n+----+-----------+-------+\n\n-- 在小张求表的 money 平均值之前，小王做了一个操作：\nSTART TRANSACTION;\nINSERT INTO user VALUES (5, 'c', 100);\nCOMMIT;\n\n-- 此时表的真实数据是：\nSELECT * FROM user;\n+----+-----------+-------+\n| id | name      | money |\n+----+-----------+-------+\n|  1 | a         |   900 |\n|  2 | b         |  1100 |\n|  3 | 小明      |  1000 |\n|  4 | 淘宝店    |  1000 |\n|  5 | c         |   100 |\n+----+-----------+-------+\n\n-- 这时小张再求平均值的时候，就会出现计算不相符合的情况：\nSELECT AVG(money) FROM user;\n+------------+\n| AVG(money) |\n+------------+\n|  820.0000  |\n+------------+\n\n虽然 READ COMMITTED 让我们只能读取到其他事务已经提交的数据，但还是会出现问题，就是在读取同一个表的数据时，可能会发生前后不一致的情况。这被称为不可重复读现象 ( READ COMMITTED ) 。\n幻读将隔离级别设置为 REPEATABLE READ ( 可被重复读取 ) :\nSET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;\nSELECT @@GLOBAL.TRANSACTION_ISOLATION;\n+--------------------------------+\n| @@GLOBAL.TRANSACTION_ISOLATION |\n+--------------------------------+\n| REPEATABLE-READ                |\n+--------------------------------+\n\n测试 REPEATABLE READ ，假设在两个不同的连接上分别执行 START TRANSACTION :\n-- 小张 - 成都\nSTART TRANSACTION;\nINSERT INTO user VALUES (6, 'd', 1000);\n\n-- 小王 - 北京\nSTART TRANSACTION;\n\n-- 小张 - 成都\nCOMMIT;\n\n当前事务开启后，没提交之前，查询不到，提交后可以被查询到。但是，在提交之前其他事务被开启了，那么在这条事务线上，就不会查询到当前有操作事务的连接。相当于开辟出一条单独的线程。\n无论小张是否执行过 COMMIT ，在小王这边，都不会查询到小张的事务记录，而是只会查询到自己所处事务的记录：\nSELECT * FROM user;\n+----+-----------+-------+\n| id | name      | money |\n+----+-----------+-------+\n|  1 | a         |   900 |\n|  2 | b         |  1100 |\n|  3 | 小明      |  1000 |\n|  4 | 淘宝店    |  1000 |\n|  5 | c         |   100 |\n+----+-----------+-------+\n\n这是因为小王在此之前开启了一个新的事务 ( START TRANSACTION ) ，那么在他的这条新事务的线上，跟其他事务是没有联系的，也就是说，此时如果其他事务正在操作数据，它是不知道的。\n然而事实是，在真实的数据表中，小张已经插入了一条数据。但是小王此时并不知道，也插入了同一条数据，会发生什么呢？\nINSERT INTO user VALUES (6, 'd', 1000);\n-- ERROR 1062 (23000): Duplicate entry '6' for key 'PRIMARY'\n\n报错了，操作被告知已存在主键为 6 的字段。这种现象也被称为幻读，一个事务提交的数据，不能被其他事务读取到。\n串行化顾名思义，就是所有事务的写入操作全都是串行化的。什么意思？把隔离级别修改成 SERIALIZABLE :\nSET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;\nSELECT @@GLOBAL.TRANSACTION_ISOLATION;\n+--------------------------------+\n| @@GLOBAL.TRANSACTION_ISOLATION |\n+--------------------------------+\n| SERIALIZABLE                   |\n+--------------------------------+\n\n还是拿小张和小王来举例：\n-- 小张 - 成都\nSTART TRANSACTION;\n\n-- 小王 - 北京\nSTART TRANSACTION;\n\n-- 开启事务之前先查询表，准备操作数据。\nSELECT * FROM user;\n+----+-----------+-------+\n| id | name      | money |\n+----+-----------+-------+\n|  1 | a         |   900 |\n|  2 | b         |  1100 |\n|  3 | 小明      |  1000 |\n|  4 | 淘宝店    |  1000 |\n|  5 | c         |   100 |\n|  6 | d         |  1000 |\n+----+-----------+-------+\n\n-- 发现没有 7 号王小花，于是插入一条数据：\nINSERT INTO user VALUES (7, '王小花', 1000);\n\n此时会发生什么呢？由于现在的隔离级别是 SERIALIZABLE ( 串行化 ) ，串行化的意思就是：假设把所有的事务都放在一个串行的队列中，那么所有的事务都会按照固定顺序执行，执行完一个事务后再继续执行下一个事务的写入操作 ( 这意味着队列中同时只能执行一个事务的写入操作 ) 。\n根据这个解释，小王在插入数据时，会出现等待状态，直到小张执行 COMMIT 结束它所处的事务，或者出现等待超时。\n","slug":"mysql_book","date":"2021-12-12T09:00:18.000Z","categories_index":"Share","tags_index":"MySQL,Dev","author_index":"XiaoJun"}]